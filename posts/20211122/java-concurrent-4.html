<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>共享模型之无锁 - 迩东陈</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="迩东陈"><meta name="msapplication-TileImage" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/head/star.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="迩东陈"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本章内容：  CAS 与 volatile 原子整数 原子引用 原子累加器 Unsafe  取款案例其实主要就是保证取款的时候如果是高并发的情况的线程安全性。 不安全实现"><meta property="og:type" content="blog"><meta property="og:title" content="共享模型之无锁"><meta property="og:url" content="https://chanservy.github.io/posts/20211122/java-concurrent-4.html"><meta property="og:site_name" content="迩东陈"><meta property="og:description" content="本章内容：  CAS 与 volatile 原子整数 原子引用 原子累加器 Unsafe  取款案例其实主要就是保证取款的时候如果是高并发的情况的线程安全性。 不安全实现"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_45.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_46.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_47.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_49.png"><meta property="article:published_time" content="2021-11-22T14:08:12.000Z"><meta property="article:modified_time" content="2022-08-31T08:06:20.591Z"><meta property="article:author" content="迩东陈"><meta property="article:tag" content="并发编程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_45.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://chanservy.github.io/posts/20211122/java-concurrent-4.html"},"headline":"共享模型之无锁","image":["https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_45.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_46.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_47.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_49.png"],"datePublished":"2021-11-22T14:08:12.000Z","dateModified":"2022-08-31T08:06:20.591Z","author":{"@type":"Person","name":"迩东陈"},"publisher":{"@type":"Organization","name":"迩东陈","logo":{"@type":"ImageObject","url":"https://chanservy.github.io/img/icarus-favicon.svg"}},"description":"本章内容：  CAS 与 volatile 原子整数 原子引用 原子累加器 Unsafe  取款案例其实主要就是保证取款的时候如果是高并发的情况的线程安全性。 不安全实现"}</script><link rel="canonical" href="https://chanservy.github.io/posts/20211122/java-concurrent-4.html"><link rel="icon" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/head/star.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/icarus-favicon.svg" alt="迩东陈" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives/">Archives</a><a class="navbar-item" href="/categories/">Categories</a><a class="navbar-item" href="/tags/">Tags</a><a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="ChanServy GitHub" href="https://github.com/ChanServy"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>共享模型之无锁</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2021-11-22T14:08:12.000Z" title="2021-11-22T14:08:12.000Z">2021-11-22</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2022-08-31T08:06:20.591Z" title="2022-08-31T08:06:20.591Z">2022-08-31</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><span class="level-item"><i class="far fa-clock"></i> 2 小时读完 (大约14330个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>本章内容：</p>
<ul>
<li>CAS 与 volatile</li>
<li>原子整数</li>
<li>原子引用</li>
<li>原子累加器</li>
<li>Unsafe</li>
</ul>
<h2 id="取款案例"><a href="#取款案例" class="headerlink" title="取款案例"></a>取款案例</h2><p>其实主要就是保证取款的时候如果是高并发的情况的线程安全性。</p>
<h3 id="不安全实现"><a href="#不安全实现" class="headerlink" title="不安全实现"></a>不安全实现</h3><span id="more"></span>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    Integer <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountImpl</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 余额</span></span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数 初始化条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> balance 余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountImpl</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 余额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取款</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance = balance - amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment"> * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountImpl</span>(<span class="number">10000</span>);<span class="comment">//账户起始10000元</span></span><br><span class="line">        List&lt;Thread&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();<span class="comment">//起始时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;<span class="comment">//1000个线程循环加到集合容器</span></span><br><span class="line">            tasks.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; account.withdraw(<span class="number">10</span>)));<span class="comment">//每个线程的任务是转出10元，1000*10=10000 正常最后余额为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread task : tasks) &#123;</span><br><span class="line">            task.start();<span class="comment">//循环启动这1000个线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread task : tasks) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                task.join(); <span class="comment">//主线程等待所有的t线程执行完之后在向下进行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.nanoTime();<span class="comment">//结束时间</span></span><br><span class="line">        System.out.println(account.getBalance() + <span class="string">&quot; cost:&quot;</span> + (endTime - startTime) / <span class="number">1000000</span> + <span class="string">&quot;ms&quot;</span>);<span class="comment">//结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">530 cost:830ms</span><br></pre></td></tr></table></figure>

<p>正常情况应该是余额为 0 。上面的实现，取款之后的余额是 530。 因为有很多个线程取款，出现了高并发的情况，造成了线程同步问题。</p>
<h3 id="解决思路：-锁"><a href="#解决思路：-锁" class="headerlink" title="解决思路： 锁"></a>解决思路： 锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.locksafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountImpl</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">//余额</span></span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountImpl</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到余额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取钱</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance = balance - amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 cost:299ms</span><br></pre></td></tr></table></figure>

<h3 id="解决思路：-无锁"><a href="#解决思路：-无锁" class="headerlink" title="解决思路： 无锁"></a>解决思路： 无锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.cassafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用cas保证线程安全性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountImpl</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    AtomicInteger balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountImpl</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要不断尝试，直到成功为止</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 比如拿到了旧值 1000</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">export</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="comment">// 在这个基础上 1000-10 = 990</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> export - amount;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * compareAndSet 正是做这个检查，在 set 前，先比较 export 与当前主内存中的balance值</span></span><br><span class="line"><span class="comment">                 - 不一致了，next 作废，返回 false 表示失败</span></span><br><span class="line"><span class="comment">                 比如，别的线程已经做了减法，当前值已经被减成了 990</span></span><br><span class="line"><span class="comment">                 那么本线程的这次 990 就作废了，进入 while 下次循环重试</span></span><br><span class="line"><span class="comment">                 - 一致，以 next 设置为新值，返回 true 表示成功</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(export, next))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以简化为下面的方法</span></span><br><span class="line">        <span class="comment">// balance.addAndGet(-1 * amount);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 cost:366ms</span><br></pre></td></tr></table></figure>

<h2 id="CAS-与-volatile"><a href="#CAS-与-volatile" class="headerlink" title="CAS 与 volatile"></a>CAS 与 volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">    <span class="comment">// 需要不断尝试，直到成功为止</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 比如拿到了旧值 1000</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">export</span> <span class="operator">=</span> balance.get();</span><br><span class="line">        <span class="comment">// 在这个基础上 1000-10 = 990</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> export - amount;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * compareAndSet 正是做这个检查，在 set 前，先比较 export 与当前主内存中的balance值</span></span><br><span class="line"><span class="comment">                 - 不一致了，next 作废，返回 false 表示失败</span></span><br><span class="line"><span class="comment">                 比如，别的线程已经做了减法，当前值已经被减成了 990</span></span><br><span class="line"><span class="comment">                 那么本线程的这次 990 就作废了，进入 while 下次循环重试</span></span><br><span class="line"><span class="comment">                 - 一致，以 next 设置为新值，返回 true 表示成功</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">        <span class="keyword">if</span> (balance.compareAndSet(export, next))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以简化为下面的方法</span></span><br><span class="line">    <span class="comment">// balance.addAndGet(-1 * amount);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面案例的代码是不断尝试直到成功。 </p>
<p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。CAS 必须配合 volatile 才会发挥作用，底层代码中的共享变量，也就代表我们传入的参数，底层是通过 volatile 来修饰的。 部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS 只有在多核 CPU 下对比起锁的实现才有明显的性能提升，并且线程数要少于 CPU 的核数性能提升显著。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</p>
<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p>
<blockquote>
<p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，能保证有序性，也就是禁止本线程发生指令重排，但不能解决指令交错问题（不能保证原子性）</p>
</blockquote>
<p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果。</p>
<h3 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高"></a>为什么无锁效率高</h3><ul>
<li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</li>
<li>线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速。。。 恢复到高速运行，代价比较大</li>
<li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换，不过总体上依然是无锁效率高。</li>
</ul>
<h3 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p>
<ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
<li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p>J.U.C 并发包提供了：</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<p>以 AtomicInteger 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.atomicIntegerExample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 按需设置参数值 如果没有要求起始值为0</span></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);<span class="comment">// i = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">        System.out.println(i.getAndIncrement());<span class="comment">// 此时i = 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">        System.out.println(i.incrementAndGet());<span class="comment">// 此时i = 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">        System.out.println(i.decrementAndGet());<span class="comment">// 此时i = 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">        System.out.println(i.getAndDecrement());<span class="comment">// 此时i = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">        System.out.println(i.getAndAdd(<span class="number">5</span>));<span class="comment">// 此时i = 5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">        System.out.println(i.addAndGet(-<span class="number">5</span>));<span class="comment">// 此时i = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line">        System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));<span class="comment">// 此时i = -2 这个方法就可以随便运算了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line">        System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));<span class="comment">// 此时i = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line">        <span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line">        <span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">        System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));<span class="comment">// 此时i = 10</span></span><br><span class="line"><span class="comment">//        System.out.println(i.getAndAccumulate(10, Integer::sum));// 此时i = 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span></span><br><span class="line">        System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));<span class="comment">// 此时i = 0</span></span><br><span class="line"><span class="comment">//        System.out.println(i.accumulateAndGet(-10, Integer::sum));// 此时i = 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>为什么需要原子引用类型？</p>
<ul>
<li>AtomicReference</li>
<li>AtomicStampedReference</li>
<li>AtomicMarkableReference</li>
</ul>
<p>上面的例子我们使用的是 Integer 类型，就是整数类型，这次使用 BigDecimal 引用类型实现。</p>
<h3 id="不安全实现-1"><a href="#不安全实现-1" class="headerlink" title="不安全实现"></a>不安全实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.unsafeRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    BigDecimal <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.unsafeRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountImpl</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 余额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数 初始化条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> balance 余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountImpl</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 余额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取款</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">        <span class="built_in">this</span>.balance = balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.unsafeRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment"> * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountImpl</span>(BigDecimal.valueOf(<span class="number">10000</span>));<span class="comment">//账户起始10000元</span></span><br><span class="line">        List&lt;Thread&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();<span class="comment">//起始时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;<span class="comment">//1000个线程循环加到集合容器</span></span><br><span class="line">            tasks.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; account.withdraw(BigDecimal.TEN)));<span class="comment">//每个线程的任务是转出10元，1000*10=10000 正常最后余额为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread task : tasks) &#123;</span><br><span class="line">            task.start();<span class="comment">//循环启动这1000个线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread task : tasks) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                task.join(); <span class="comment">//主线程等待所有的t线程执行完之后在向下进行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.nanoTime();<span class="comment">//结束时间</span></span><br><span class="line">        System.out.println(account.getBalance() + <span class="string">&quot; cost:&quot;</span> + (endTime - startTime) / <span class="number">1000000</span> + <span class="string">&quot;ms&quot;</span>);<span class="comment">//结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2700 cost:501ms</span><br></pre></td></tr></table></figure>

<h3 id="解决思路：-锁-1"><a href="#解决思路：-锁-1" class="headerlink" title="解决思路： 锁"></a>解决思路： 锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.locksafeRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountImpl</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    BigDecimal balance;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountImpl</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            balance = balance.subtract(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 cost:374ms</span><br></pre></td></tr></table></figure>

<h3 id="解决思路：-无锁-1"><a href="#解决思路：-无锁-1" class="headerlink" title="解决思路： 无锁"></a>解决思路： 无锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.cassafeRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountImpl</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountImpl</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">perv</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">next</span> <span class="operator">=</span> perv.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(perv, next))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 cost:330ms</span><br></pre></td></tr></table></figure>

<h2 id="ABA-问题及解决"><a href="#ABA-问题及解决" class="headerlink" title="ABA 问题及解决"></a>ABA 问题及解决</h2><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.ABA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取值 A</span></span><br><span class="line">        <span class="comment">// 这个共享变量被它线程修改过？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.get();</span><br><span class="line">        otherThread();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.get();</span><br><span class="line">                log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;B&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">17:21:35 [main] c.Test - main start...</span><br><span class="line">17:21:35 [t1] c.Test - change A-&gt;B true</span><br><span class="line">17:21:36 [t2] c.Test - change B-&gt;A true</span><br><span class="line">17:21:38 [main] c.Test - change A-&gt;C true</span><br></pre></td></tr></table></figure>

<p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况，如果主线程希望：</p>
<p>只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号。</p>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.ABA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取值 A</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">        <span class="comment">// 获取版本号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">        log.debug(<span class="string">&quot;版本 &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span></span><br><span class="line">        other();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 尝试改为 C</span></span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">            log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">            log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">17:35:48 [main] c.Test2 - main start...</span><br><span class="line">17:35:48 [main] c.Test2 - 版本 0</span><br><span class="line">17:35:48 [t1] c.Test2 - change A-&gt;B true</span><br><span class="line">17:35:48 [t1] c.Test2 - 更新版本为 1</span><br><span class="line">17:35:49 [t2] c.Test2 - change B-&gt;A true</span><br><span class="line">17:35:49 [t2] c.Test2 - 更新版本为 2</span><br><span class="line">17:35:51 [main] c.Test2 - change A-&gt;C false</span><br></pre></td></tr></table></figure>

<p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，另外我们可以知道，引用变量中途被更改了几次。</p>
<p>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 AtomicMarkableReference</p>
<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>注释掉打扫卫生线程代码和不注释相比较，观察输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.ABA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestABAAtomicMarkableReference&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestABAAtomicMarkableReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">bag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;装满了垃圾&quot;</span>);</span><br><span class="line">        <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(bag, <span class="literal">true</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;主线程 start...&quot;</span>);</span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">        log.debug(prev.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;打扫卫生的线程 start...&quot;);</span></span><br><span class="line"><span class="comment">//            bag.setDesc(&quot;空垃圾袋&quot;);</span></span><br><span class="line"><span class="comment">//            while (!ref.compareAndSet(bag, bag, true, false)) &#123;&#125;</span></span><br><span class="line"><span class="comment">//            log.debug(bag.toString());</span></span><br><span class="line"><span class="comment">//        &#125;).start();</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;主线程想换一只新垃圾袋？&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> ref.compareAndSet(prev, <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;空垃圾袋&quot;</span>), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;换了么？&quot;</span> + success);</span><br><span class="line">        log.debug(ref.getReference().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GarbageBag</span> &#123;</span><br><span class="line">    String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GarbageBag</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GarbageBag&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17:57:42 [main] c.TestABAAtomicMarkableReference - 主线程 start...</span><br><span class="line">17:57:42 [main] c.TestABAAtomicMarkableReference - GarbageBag&#123;desc=&#x27;装满了垃圾&#x27;&#125;</span><br><span class="line">17:57:43 [main] c.TestABAAtomicMarkableReference - 主线程想换一只新垃圾袋？</span><br><span class="line">17:57:43 [main] c.TestABAAtomicMarkableReference - 换了么？true</span><br><span class="line">17:57:43 [main] c.TestABAAtomicMarkableReference - GarbageBag&#123;desc=&#x27;空垃圾袋&#x27;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.ABA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestABAAtomicMarkableReference&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestABAAtomicMarkableReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">bag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;装满了垃圾&quot;</span>);</span><br><span class="line">        <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(bag, <span class="literal">true</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;主线程 start...&quot;</span>);</span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">        log.debug(prev.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;打扫卫生的线程 start...&quot;</span>);</span><br><span class="line">            bag.setDesc(<span class="string">&quot;空垃圾袋&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="literal">true</span>, <span class="literal">false</span>)) &#123;&#125;</span><br><span class="line">            log.debug(bag.toString());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;主线程想换一只新垃圾袋？&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> ref.compareAndSet(prev, <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;空垃圾袋&quot;</span>), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;换了么？&quot;</span> + success);</span><br><span class="line">        log.debug(ref.getReference().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GarbageBag</span> &#123;</span><br><span class="line">    String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GarbageBag</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GarbageBag&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">17:59:42 [main] c.TestABAAtomicMarkableReference - 主线程 start...</span><br><span class="line">17:59:42 [main] c.TestABAAtomicMarkableReference - GarbageBag&#123;desc=&#x27;装满了垃圾&#x27;&#125;</span><br><span class="line">17:59:42 [Thread-0] c.TestABAAtomicMarkableReference - 打扫卫生的线程 start...</span><br><span class="line">17:59:42 [Thread-0] c.TestABAAtomicMarkableReference - GarbageBag&#123;desc=&#x27;空垃圾袋&#x27;&#125;</span><br><span class="line">17:59:43 [main] c.TestABAAtomicMarkableReference - 主线程想换一只新垃圾袋？</span><br><span class="line">17:59:43 [main] c.TestABAAtomicMarkableReference - 换了么？false</span><br><span class="line">17:59:43 [main] c.TestABAAtomicMarkableReference - GarbageBag&#123;desc=&#x27;空垃圾袋&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>目的就是保证垃圾袋是空的，线程 t 就好比把垃圾到了，垃圾袋没换，主线程就是将垃圾袋整个换成新的垃圾袋，这两种做法都可以保证垃圾袋是空的，上面的代码，主线程在换垃圾袋之前睡了一秒，所以是 t 线程先执行完倒垃圾，但是倒垃圾并不是换一个新的垃圾袋，因此还是之前的旧的对象，当主线程执行的时候，如果按照一般的 CAS 思路，比较并替换，我们知道引用类型的对象比较的是对象的内存地址，我们的垃圾袋对象一直没变，因此是符合置换要求的可以替换，因此这时主线程又用new GarbageBag(“空垃圾袋”)，去替换了prev，但是实际上有意义么? 是没意义的，因为我们的垃圾袋已经是空的了，需求已经达成，就不需要再去换一个新的垃圾袋了，所以我们这个时候使用的是 <code>AtomicMarkableReference</code> 类，设置了一个标记，倒垃圾之后将标记更改，等主线程来了想要换垃圾袋的时候查看标记，如果标记垃圾袋已经为空了，那就不用再换新的垃圾袋了。</p>
<h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><ul>
<li>AtomicIntegerArray 整数 Integer 类型的数组</li>
<li>AtomicLongArray 整数 Long 类型的数组</li>
<li>AtomicReferenceArray 引用类型的数组，String 或者自定义类等</li>
</ul>
<h3 id="不安全的数组"><a href="#不安全的数组" class="headerlink" title="不安全的数组"></a>不安全的数组</h3><p><strong>函数式接口</strong>： </p>
<p>在下面实现了一个通用的比较方法(demo)，让 LongAdder 对象 和 AtomicLong 对象 都使用这同一个方法的流程，保证公平性。<br>Supplier接口 和 Consumer接口 都是 函数式接口（即有且仅有一个抽象方法，但是可以有多个非抽象方法的接口）<br>Supplier接口的抽象方法可作为提供者，不传入参数，但返回结果；<br>Consumer接口的抽象方法可作为消费者，传入一个参数，但不返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.atomicArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 不安全的数组</span></span><br><span class="line">        demo(</span><br><span class="line">                () -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>],</span><br><span class="line">                (array) -&gt; array.length,</span><br><span class="line">                (array, index) -&gt; array[index]++,</span><br><span class="line">                (array) -&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment">     * 参数2，获取数组长度的方法</span></span><br><span class="line"><span class="comment">     * 参数3，自增方法，传 array, index</span></span><br><span class="line"><span class="comment">     * 参数4，打印数组的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 函数式接口 接口中定义一个方法</span></span><br><span class="line">    <span class="comment">// supplier 提供者 无中生有 ()-&gt;结果</span></span><br><span class="line">    <span class="comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span></span><br><span class="line">    <span class="comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(</span></span><br><span class="line"><span class="params">            Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="line"><span class="params">            Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="line"><span class="params">            BiConsumer&lt;T, Integer&gt; putConsumer,</span></span><br><span class="line"><span class="params">            Consumer&lt;T&gt; printConsumer</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">T</span> <span class="variable">array</span> <span class="operator">=</span> arraySupplier.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> lengthFun.apply(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 一共length个线程,每个线程对数组作 10000 次操作</span></span><br><span class="line">            threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        putConsumer.accept(array, j % length);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123; <span class="comment">// 启动所有线程</span></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 等所有线程结束</span></span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[8958, 8925, 8936, 8947, 8959, 8944, 8934, 8939, 8960, 8972]</span><br></pre></td></tr></table></figure>

<h3 id="安全的数组"><a href="#安全的数组" class="headerlink" title="安全的数组"></a>安全的数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.atomicArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 安全的数组</span></span><br><span class="line">        demo(</span><br><span class="line">                () -&gt; <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="number">10</span>),</span><br><span class="line">                (array) -&gt; array.length(),</span><br><span class="line">                (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">                (array) -&gt; System.out.println(array)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment">     * 参数2，获取数组长度的方法</span></span><br><span class="line"><span class="comment">     * 参数3，自增方法，传 array, index</span></span><br><span class="line"><span class="comment">     * 参数4，打印数组的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// supplier 提供者 无中生有 ()-&gt;结果</span></span><br><span class="line">    <span class="comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span></span><br><span class="line">    <span class="comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(</span></span><br><span class="line"><span class="params">            Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="line"><span class="params">            Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="line"><span class="params">            BiConsumer&lt;T, Integer&gt; putConsumer,</span></span><br><span class="line"><span class="params">            Consumer&lt;T&gt; printConsumer</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">T</span> <span class="variable">array</span> <span class="operator">=</span> arraySupplier.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> lengthFun.apply(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 一共length个线程,每个线程对数组作 10000 次操作</span></span><br><span class="line">            threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        putConsumer.accept(array, j % length);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br></pre></td></tr></table></figure>

<h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><ul>
<li>AtomicReferenceFieldUpdater  域字段是引用类型</li>
<li>AtomicIntegerFieldUpdater 域字段是整数类型</li>
<li>AtomicLongFieldUpdater</li>
</ul>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Must be volatile type</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.atomicFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> field;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AtomicIntegerFieldUpdater 处理int类型的字段的原子性</span></span><br><span class="line">        AtomicIntegerFieldUpdater&lt;Test&gt; fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Test.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> fieldUpdater.compareAndSet(test, <span class="number">0</span>, <span class="number">10</span>);<span class="comment">//返回布尔值 为true则将新的值设置 为false则保持旧值不变</span></span><br><span class="line">        System.out.println(a);<span class="comment">// 修改成功 field = 10</span></span><br><span class="line">        System.out.println(test.field);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> fieldUpdater.compareAndSet(test, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(b);<span class="comment">// 修改成功 field = 20</span></span><br><span class="line">        System.out.println(test.field);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> fieldUpdater.compareAndSet(test, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">// 修改失败 field = 20</span></span><br><span class="line">        System.out.println(test.field);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// AtomicReferenceFieldUpdater 处理引用类型的字段的原子性</span></span><br><span class="line">        AtomicReferenceFieldUpdater&lt;Student, String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">d</span> <span class="operator">=</span> updater.compareAndSet(student, <span class="literal">null</span>, <span class="string">&quot;陈陈陈&quot;</span>);</span><br><span class="line">        System.out.println(d);<span class="comment">// 修改成功 name = &quot;陈陈陈&quot;</span></span><br><span class="line">        System.out.println(student);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">10</span><br><span class="line">true</span><br><span class="line">20</span><br><span class="line">false</span><br><span class="line">20</span><br><span class="line">true</span><br><span class="line">Student&#123;name=&#x27;陈陈陈&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><h3 id="累加器性能比较"><a href="#累加器性能比较" class="headerlink" title="累加器性能比较"></a>累加器性能比较</h3><p>比较 AtomicLong 与 LongAdder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.longAdder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 比较 AtomicLong 与 LongAdder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(), (adder) -&gt; adder.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>(), (adder) -&gt; adder.increment());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;T&gt; supplier, Consumer&lt;T&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">adder</span> <span class="operator">=</span> supplier.get();<span class="comment">// adder为共享变量</span></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 个线程，每个线程都去主内存中拿adder, 每个线程对adder各累加 50 万, 在线程安全的情况下, adder最后应该是2000000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                        consumer.accept(adder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start)/<span class="number">1000000</span> + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2000000 cost:298ms</span><br><span class="line">2000000 cost:253ms</span><br><span class="line">2000000 cost:229ms</span><br><span class="line">2000000 cost:221ms</span><br><span class="line">2000000 cost:235ms</span><br><span class="line">2000000 cost:69ms</span><br><span class="line">2000000 cost:29ms</span><br><span class="line">2000000 cost:28ms</span><br><span class="line">2000000 cost:29ms</span><br><span class="line">2000000 cost:22ms</span><br></pre></td></tr></table></figure>

<h3 id="性能提升的原因"><a href="#性能提升的原因" class="headerlink" title="性能提升的原因"></a>性能提升的原因</h3><p>如果使用 AtomicLong 实现累加，底层是 cas 思想，在多线程竞争时，它要使用 while(true) 循环不断尝试更新，直到能成功，但是竞争如果比较激烈，往一个共享变量上做累加，必然竞争比较激烈，重试的次数越多，累加的速率越低。 </p>
<p>如果使用 LongAdder 实现累加，它是在有竞争的时候设置多个累加单元，不是在一个共享变量上累加，这样比如 Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]。。。 线程 1 向共享变量 1 上累加，线程 2 向共享变量 2 上累加，最后将结果汇总。这样它们在累加时操作的不同的共享变量 Cell 变量(累加单元)，因此减少了 CAS 失败重试的次数，从而提高性能。这个增加累加单元的思想很像 forkjoin。</p>
<p>累加单元与 CPU 的核数有关，再多不会超过 CPU 的核数，因为超了核心数的话，CAS 便意义不大了。 所以核心数越多，性能越好。 </p>
<h3 id="LongAdder源码剖析"><a href="#LongAdder源码剖析" class="headerlink" title="LongAdder源码剖析"></a>LongAdder源码剖析</h3><p>LongAdder 是并发大师 @author Doug Lea 的作品，设计的非常精巧。</p>
<p>前面介绍的 Java 中的一些原子类，基本都是通过 CAS 来实现原子性操作，白白浪费 CPU 资源。JDK8 中新增了一个原子性递增或者递减类 LongAdder 用来克服高并发下使用 AtomicLong 的缺点。LongAdder 的思路是<strong>把一个变量分解为多个变量，让同样多的线程去竞争多个资源</strong>。</p>
<p>首先，LongAdder 类有几个关键域。 LongAdder继承自Striped64，在Striped64中维护者三个变量：base、cellsBusy、Cell数组。base是个基础知识，默认为0。cellsBusy用来实现自旋锁，状态值只有0和1，当创建Cell元素，扩容Cell数组或者初始化Cell数组时，使用CAS操作该变量来保证同时只有一个线程可以进行其中之一的操作。所以cells是volatile的，但没有加锁，而是用的自旋锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化, 有竞争的时候用</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<p>使用LongAdder时，内部维护了多个Cell变量(多个累加单元)，每个Cell里面有一个初始值为0的long型变量，这样同时竞争一个变量的线程数量就变少了，而是所有线程分散成对多个变量的竞争，减少了失败次数。<strong>如果竞争某个Cell变量失败，它不会一直在这个Cell变量上自旋CAS重试，而是尝试在其他的Cell变量上进行CAS尝试</strong>，这个改变增加了当前线程重试CAS成功的可能性。<strong>最后，在获取LongAdder当前值时，是把所有Cell变量的value值累加后再加上base返回的</strong>。</p>
<p>LongAdder里面有一个<strong>Cell数组，是惰性加载的，即需要时创建</strong>。当并发线程较少时，所有累加操作都是针对base变量进行。Cell类型是AtomicLong的一个改进，用来减少缓存的争用，也就是解决伪共享问题。因为Cell数组元素的内存地址是连续的，所以数组内的多个元素能经常共享缓存行，因此这里使用@sun.misc.Contended注解对Cell类进行字节填充，防止数组中多个元素共享一个缓存行，提升性能。</p>
<p>transient ： 序列化时不会把这些进行序列化</p>
<p>LongAdder 源码底层用到 cas 加锁，也即是 cellsBusy 为 1 的标记加锁，这种机制来保护 cells 创建或扩容时的安全。</p>
<p>下面的代码不要用在项目中，因为是有风险的，空运转可能导致对性能的影响。</p>
<h4 id="cas-锁-demo"><a href="#cas-锁-demo" class="headerlink" title="cas 锁 demo"></a>cas 锁 demo</h4><p>LongAdder 里面就是使用了 cas 方式实现的锁，所以在这里预演一个 demo，方便理解 cellsBusy 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.longAdder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用cas思想实现的锁, 这个方式拿不到锁不是阻塞而是一直循环, 不要用于生产实践</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.CasLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CasLock</span> &#123;</span><br><span class="line">    <span class="comment">// 初始值设置为0</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">ai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);<span class="comment">//状态只有0和1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> ai.get();<span class="comment">// 期望值为0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// 新值</span></span><br><span class="line">            <span class="keyword">if</span> (ai.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;unlock...&quot;</span>);</span><br><span class="line">        ai.set(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.CasLockTest&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CasLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CasLock</span> <span class="variable">casLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CasLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            casLock.lock();<span class="comment">// 使用cas实现的锁, 要么成功拿到锁向下执行, 要么空转一直循环尝试, 这里就不叫阻塞了, 而是一直尝试,自旋锁 </span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock...&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                casLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            casLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                casLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">21:46:54 [t2] c.CasLockTest - begin...</span><br><span class="line">21:46:54 [t2] c.CasLockTest - lock...</span><br><span class="line">21:46:54 [t1] c.CasLockTest - begin...</span><br><span class="line">21:46:54 [t2] c.CasLock - unlock...</span><br><span class="line">21:46:54 [t1] c.CasLockTest - lock...</span><br><span class="line">21:46:55 [t1] c.CasLock - unlock...</span><br></pre></td></tr></table></figure>

<h4 id="LongAdder-源码分析"><a href="#LongAdder-源码分析" class="headerlink" title="LongAdder 源码分析"></a>LongAdder 源码分析</h4><p>接下来的的解析都围绕着六个问题来进行：</p>
<ol>
<li>LongAdder的结构是怎样的？</li>
<li>线程访问Cell数组的哪一个Cell元素？</li>
<li>如何初始化Cell数组？</li>
<li>Cell数组如何扩容？</li>
<li>线程访问分配的Cell元素有冲突后如何处理？</li>
<li>如何保证线程操作被分配的Cell元素的原子性？</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较 AtomicLong 与 LongAdder</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      demo(() -&gt; <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(), (adder) -&gt; adder.incrementAndGet());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      demo(() -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>(), (adder) -&gt; adder.increment());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们从 adder.increment() 的方法点进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Equivalent to &#123;<span class="doctag">@code</span> add(1)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    add(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再点 add 方法进到里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the given value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the value to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不看别的，再点击 longAccumulate 方法进到里面：</p>
<p>提前说明一下源码中的几个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getProbe</span><span class="params">()</span> <span class="comment">//方法，用来获得线程对应的probe值，类似于hash值，是一种hash函数映射。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">advanceProbe</span><span class="params">(<span class="type">int</span> probe)</span> <span class="comment">//方法：用来重新生成一个probe值，为什么要重新生成呢？因为在之前的probe映射到的cell中累加，一直失败。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">casCellsBusy</span><span class="params">()</span> <span class="comment">//方法：用来上cas锁 ——— 上锁成功则返回true，此时cellsBusy应为1；上锁失败则返回false，证明有其他线程正在使用锁；使用锁结束后，应该让cellsBusy = 0，变成无锁状态。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Handles cases of updates involving initialization, resizing,</span></span><br><span class="line"><span class="comment">    * creating new Cells, and/or contention. See above for</span></span><br><span class="line"><span class="comment">    * explanation. This method suffers the usual non-modularity</span></span><br><span class="line"><span class="comment">    * problems of optimistic retry code, relying on rechecked sets of</span></span><br><span class="line"><span class="comment">    * reads.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> x the value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fn the update function, or null for add (this convention</span></span><br><span class="line"><span class="comment">    * avoids the need for an extra field or function in LongAdder).</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> wasUncontended false if CAS failed before call</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//都有哪些情况会调用？</span></span><br><span class="line">   <span class="comment">//1.true-&gt; cells 未初始化，也就是多线程写base发生竞争了[初始化cells]</span></span><br><span class="line">   <span class="comment">//         执行CASE2</span></span><br><span class="line">   <span class="comment">//2.true-&gt; cells 已初始化，但是当前线程对应下标的cell为空，需要创建 longAccumulate 支持</span></span><br><span class="line">   <span class="comment">//         执行CASE1.1</span></span><br><span class="line">   <span class="comment">//3.true-&gt; cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]</span></span><br><span class="line">   <span class="comment">//         执行CASE1.3 失败 -&gt; CASE1.5 -&gt; rehash，即执行advanceProbe(h) -&gt; 自旋 -&gt; 执行CASE1.3 再失败 -&gt; CASE1.6()因为CASE1.5中将设置扩容意向为true</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// wasUncontended：只有cells初始化之后，并且当前线程 竞争修改失败，才会是false</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                             <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">       <span class="comment">//h 表示线程hash值</span></span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line">       <span class="comment">//条件成立：说明当前线程 还未分配hash值</span></span><br><span class="line">       <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//给当前线程分配hash值</span></span><br><span class="line">           ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">           <span class="comment">//取出当前线程的hash值 赋值给h</span></span><br><span class="line">           h = getProbe();</span><br><span class="line">           <span class="comment">//为什么wasUncontended设置为true？</span></span><br><span class="line">           <span class="comment">//代码执行到这里，说明线程没有分配hash值(hash=0)</span></span><br><span class="line">           <span class="comment">//所以 当前线程 肯定是写入到了 cells[0] 位置(0 &amp; 任意数 = 0)。 不把它当做一次真正的竞争</span></span><br><span class="line">           wasUncontended = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//表示扩容意向。 false 一定不会扩容；true 可能会扩容。</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//自旋</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">//as 表示cells引用</span></span><br><span class="line">           <span class="comment">//a 表示当前线程命中的cell</span></span><br><span class="line">           <span class="comment">//n 表示cells数组长度</span></span><br><span class="line">           <span class="comment">//v 表示 期望值</span></span><br><span class="line">           Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//CASE1： 表示cells已经初始化了，当前线程应该将数据写入到对应的cell中</span></span><br><span class="line">           <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//进入这个if，有下面两种情况</span></span><br><span class="line">               <span class="comment">//2.true-&gt; 说明当前线程对应下标的cell为空，需要创建 longAccumulate 支持</span></span><br><span class="line">               <span class="comment">//3.true-&gt;表示cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//CASE1.1：true-&gt;表示当前线程对应的下标位置的cell为null，需要创建new Cell</span></span><br><span class="line">               <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//true-&gt;表示当前锁 未被占用； false-&gt;表示锁被占用</span></span><br><span class="line">                   <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line"></span><br><span class="line">                       <span class="comment">//拿当前的x创建Cell</span></span><br><span class="line">                       <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line"></span><br><span class="line">                       <span class="comment">//条件一：true-&gt;表示当前锁 未被占用； false-&gt;表示锁被占用</span></span><br><span class="line">                       <span class="comment">//条件二：true-&gt;表示当前线程获取锁成功； false-&gt;当前线程获取锁失败。</span></span><br><span class="line">                       <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                           <span class="comment">//是否创建成功的标记</span></span><br><span class="line">                           <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                           <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                               <span class="comment">//rs 表示当前cells 引用</span></span><br><span class="line">                               <span class="comment">//m 表示cells长度</span></span><br><span class="line">                               <span class="comment">//j 表示当前线程命中的下标</span></span><br><span class="line">                               Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line"></span><br><span class="line">                               <span class="comment">//条件一 条件二 为true</span></span><br><span class="line">                               <span class="comment">//条件三：rs[j = (m - 1) &amp; h] == null 为了防止其它线程初始化过该位置，然后当前线程再次初始化该位置，导致丢失数据</span></span><br><span class="line">                               <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                       (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                       rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                   rs[j] = r;</span><br><span class="line">                                   created = <span class="literal">true</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                               cellsBusy = <span class="number">0</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">if</span> (created)</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//扩容意向 强制改为了false</span></span><br><span class="line">                   collide = <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// CASE1.2：true -&gt; wasUncontended：只有cells初始化之后，并且当前线程 竞争修改失败，才会是false</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                   wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">               <span class="comment">//CASE 1.3：当前线程rehash过hash值，然后新命中的cell不为空</span></span><br><span class="line">               <span class="comment">//true -&gt; 写成功,退出循环</span></span><br><span class="line">               <span class="comment">//false -&gt; 表示rehash之后命中的新的cell 也有竞争</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                       fn.applyAsLong(v, x))))</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="comment">//CASE 1.4：</span></span><br><span class="line">               <span class="comment">//条件一：n &gt;= NCPU 为 true-&gt;就会把扩容意向改为false，不再扩容； false-&gt; 说明cells数组还可以扩容</span></span><br><span class="line">               <span class="comment">//条件二：cells != as 为 true-&gt;其它线程已经扩容过了，当前线程rehash之后重试即可</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                   <span class="comment">//扩容意向为false，表示不扩容了</span></span><br><span class="line">                   collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">               <span class="comment">//CASE 1.5：</span></span><br><span class="line">               <span class="comment">//!collide == true 设置扩容意向 为true 但是不一定真的发生扩容</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                   collide = <span class="literal">true</span>;</span><br><span class="line">               <span class="comment">//CASE 1.6：真正扩容的逻辑</span></span><br><span class="line">               <span class="comment">//条件一：cellsBusy == 0 true-&gt;表示当前无锁状态，当前线程可以去竞争这把锁</span></span><br><span class="line">               <span class="comment">//条件二：casCellsBusy true-&gt;表示当前线程 获取锁 成功，可以执行扩容逻辑</span></span><br><span class="line">               <span class="comment">// false-&gt;表示当前时刻有其它线程在做扩容相关的操作。</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//这里又判断了一次cells == as。  防止其它线程已经扩容了，当前线程再次扩容。cells的引用就会发生变化，导致数据流失</span></span><br><span class="line">                       <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                           <span class="comment">//数组长度扩容，得到新数组，新长度等于旧长度左移1位，等价于 新长度=旧长度*2</span></span><br><span class="line">                           Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                           <span class="comment">//遍历旧数组，将旧数组对应位置的值放到新数组中</span></span><br><span class="line">                           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                               rs[i] = as[i];</span><br><span class="line">                           <span class="comment">//将新数组的引用赋值给全局的cells</span></span><br><span class="line">                           cells = rs;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">//释放锁</span></span><br><span class="line">                       cellsBusy = <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   collide = <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//修改失败，就会重置当前线程Hash值，然后当前线程自旋，再次修改时，就会到不同的cell上</span></span><br><span class="line">               h = advanceProbe(h);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CASE2：前置条件cells还未初始化，as 为null</span></span><br><span class="line">           <span class="comment">//条件一：true 表示当前未加锁</span></span><br><span class="line">           <span class="comment">//条件二：为什么cells == as？短路原则，当判断这个条件时，条件一为true，表示其他线程已经持有锁了</span></span><br><span class="line">           <span class="comment">//       那么其它线程在执行下面的初始化方法，可能会在你给as赋值为null之后修改了 cells，所以这里再判断一次</span></span><br><span class="line">           <span class="comment">//条件三：true 表示获取锁成功 会把cellsBusy = 1，false 表示其它线程正在持有这把锁</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">               <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                   <span class="comment">//这里又判断了一次cells == as。  防止其它线程已经初始化了，当前线程再次初始化 导致丢失数据</span></span><br><span class="line">                   <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                       Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                       rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                       cells = rs;</span><br><span class="line">                       init = <span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   cellsBusy = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (init)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CASE3：前面两个if中所有条件都为false才会执行到这，说明：</span></span><br><span class="line">           <span class="comment">//1.当前cellsBusy加锁状态，表示其它线程正在初始化cells，所以当前线程将值累加到base</span></span><br><span class="line">           <span class="comment">//2.cells被其它线程初始化后，当前线程需要将数据累加到base</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                   fn.applyAsLong(v, x))))</span><br><span class="line">               <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在是在 Striped64 类中，我们继续向上翻，找到学习 LongAdder 的核心以及出发点，也就是下面的 Cell 累加单元类. 为什么说它是核心以及出发点，我们都知道 LongAdder 和 AtomicLong 的功能是一样的都是累加，但是 LongAdder 的速率要高于 AtomicLong ，那么为什么比 AtomicLong 的速度快，就是因为 LongAdder 改进了可以增加累加单元，那累加单元类就是下面的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Padded variant of AtomicLong supporting only raw accesses plus CAS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * JVM intrinsics note: It would be possible to use a release-only</span></span><br><span class="line"><span class="comment"> * form of CAS here, if it were provided.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，一个Cell维护一个volatile的变量，和Cell数组类似，这里设置成volatile但并没有加锁主要是利用了cas来保证内部value的原子性更改，这也回答了<strong>问题6，即如何保证线程操作被分配的Cell元素的原子性</strong> 。类Cell使用@sun.misc.Contended修饰是为了避免伪共享，因为Cell数组是连续的，很容易出现这种问题。我们也弄懂了<strong>问题1，即LongAdder的结构是怎样的</strong>。</p>
<h4 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h4><p>@sun.misc.Contended 看这个注解： 这个注解的作用就是为了防止<strong>缓存行共享</strong></p>
<p>缓存行共享就是我们说的伪共享，要先从缓存说起。 </p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_45.png"></p>
<table>
<thead>
<tr>
<th>从 CPU 到</th>
<th>大约需要的时钟周期</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1 cycle (4GHz 的 CPU 约为0.25ns)</td>
</tr>
<tr>
<td>L1</td>
<td>3~4 cycle</td>
</tr>
<tr>
<td>L2</td>
<td>10~20cycle</td>
</tr>
<tr>
<td>L3</td>
<td>40~45cycle</td>
</tr>
<tr>
<td>主内存</td>
<td>120~240cycle</td>
</tr>
</tbody></table>
<p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。</p>
<p>而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long）</p>
<p>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中</p>
<p>CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效</strong></p>
<p>注： CPU 的三级缓存，为了方便在下图中统一画一个缓存行</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_46.png"></p>
<p>因为 Cell 是<strong>数组形式，在内存中是连续存储的</strong>，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p>
<ul>
<li>Core-0 要修改 Cell[0]</li>
<li>Core-1 要修改 Cell[1]</li>
</ul>
<p>无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]&#x3D;6000，Cell[1]&#x3D;8000 要累加 Cell[0]&#x3D;6001，Cell[1]&#x3D;8000 ，这时会让 Core-1 的缓存行失效。</p>
<p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效。</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_47.png"></p>
<p>其实就是空间换取时间，让每个累加单元独占一个核心的缓存行。</p>
<p>我们将这种一个核心的缓存行中加入了多个累加单元的现象成为伪共享，一个改动，其它整体失效，其它都要重新加载，会影响效率，这个注解的作用就是防止伪共享。 提高效率。</p>
<p>接下来回过头来看前面的 add 方法，累加主要调用这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// as 为累加单元数组</span></span><br><span class="line">    <span class="comment">// b 为基础值</span></span><br><span class="line">    <span class="comment">// x 为累加值</span></span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">// 进入 if 的两个条件</span></span><br><span class="line">    <span class="comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span></span><br><span class="line">    <span class="comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;   		<span class="comment">//(1)</span></span><br><span class="line">        <span class="comment">// uncontended 表示 cell 没有竞争</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// as 还没有创建</span></span><br><span class="line">                as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||            <span class="comment">//(2)       </span></span><br><span class="line">                        <span class="comment">// 当前线程对应的 cell 还没有</span></span><br><span class="line">                        (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||			<span class="comment">//(3)</span></span><br><span class="line">                        <span class="comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span></span><br><span class="line">                        !(uncontended = a.cas(v = a.value, v + x))	<span class="comment">//(4)</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 进入 cell 数组创建、cell 创建的流程</span></span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);					<span class="comment">//(5)		</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意这个函数里面的判断条件虽然是或的关系，其实是层层递进的。</p>
<ol>
<li>代码（1）先看cells是否为null，如果不为空则直接执内部代码块，为空则先尝试在base变量上进行累加。</li>
<li>如果累加base变量成功了，则直接返回，失败了则执行内部代码块。</li>
<li>代码（2）如果cells是空的（as&#x3D;&#x3D;null或者as的长度为0），则执行代码（5）进行累加；不为空则得到要当前线程要访问的cell（即变量a，下标是通过getProb() &amp; m获取的）。</li>
<li>如果要访问的cell为空，则执行代码（5），否则就对访问的cas进行原子改变操作，并返回uncontended变量查看是否执行成功，成功了直接返回，失败了还是要执行代码（5）。</li>
</ol>
<p>这个地方我们就回答了<strong>问题2，即如何知道当前线程是访问哪一个cell呢</strong>，通过getProbe() &amp; m获取下标，进而从cells数组中取得。m代表当前cells数组元素个数-1，getProbe()用于获取当前线程中变量threadLocalRandomProbe的值，它一开始为0，在代码5中会对其进行初始化。</p>
<p>接下来就是longAccumulate方法了，我们通过分析add方法的逻辑，知道了LongAdder中调用longAccumulate的原因：（三者之一）</p>
<ol>
<li>cells 未初始化，但是多线程写base发生竞争了[进入longAccumulate初始化cells]</li>
<li>cells 已初始化，但是当前线程对应下标的cell为空，需要创建 longAccumulate 支持</li>
<li>cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]</li>
</ol>
<ul>
<li>情况一：说明 cells 未初始化，也就是多线程写base发生竞争了[初始化cells]，会进入case2，当前线程拿到锁并进入扩容；如果当前线程没有获取到锁或者其他线程已经初始化了，则进入case3，表示其它线程正在初始化cells，所以当前线程将值累加到base</li>
<li>情况二、情况三都会进入case1，表示cells已经初始化了，当前线程应该将数据写入到对应的cell中<ul>
<li>情况二：说明当前线程对应下标的cell为空，需要创建 longAccumulate 支持，进入case1.1，创建new Cell</li>
<li>情况三：表示cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]<ul>
<li>cell已经有了但是在写的时候发生了竞争，进入case1.2，这时wasUncontended为false，取反为true，进入该条件，将这个值设置为true，进行rehash</li>
<li>自旋重新进入case1，cell不为空的话进入case1.3尝试一次，成功则退出自旋循环，否则进入case1.5，将collide设置为true，再次rehash，再次查看case1.3条件是否满足，不满足则会直接进入到case1.6，这里才是真正的扩容方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：这里的case1.4是累加单元数组的长度不能超过cpu核心的数量，因为我们要保证一个核心的缓存行对应一个累加单元。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Handles cases of updates involving initialization, resizing,</span></span><br><span class="line"><span class="comment">    * creating new Cells, and/or contention. See above for</span></span><br><span class="line"><span class="comment">    * explanation. This method suffers the usual non-modularity</span></span><br><span class="line"><span class="comment">    * problems of optimistic retry code, relying on rechecked sets of</span></span><br><span class="line"><span class="comment">    * reads.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> x the value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fn the update function, or null for add (this convention</span></span><br><span class="line"><span class="comment">    * avoids the need for an extra field or function in LongAdder).</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> wasUncontended false if CAS failed before call</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//都有哪些情况会调用？</span></span><br><span class="line">   <span class="comment">//1.true-&gt; cells 未初始化，也就是多线程写base发生竞争了[初始化cells]</span></span><br><span class="line">   <span class="comment">//         执行CASE2</span></span><br><span class="line">   <span class="comment">//2.true-&gt; cells 已初始化，但是当前线程对应下标的cell为空，需要创建 longAccumulate 支持</span></span><br><span class="line">   <span class="comment">//         执行CASE1.1</span></span><br><span class="line">   <span class="comment">//3.true-&gt; cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]</span></span><br><span class="line">   <span class="comment">//         执行CASE1.3 失败 -&gt; CASE1.5 -&gt; rehash，即执行advanceProbe(h) -&gt; 自旋 -&gt; 执行CASE1.3 再失败 -&gt; CASE1.6()因为CASE1.5中将设置扩容意向为true</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// wasUncontended：只有cells初始化之后，并且当前线程 竞争修改失败，才会是false</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                             <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">       <span class="comment">//h 表示线程hash值</span></span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line">       <span class="comment">//条件成立：说明当前线程 还未分配hash值</span></span><br><span class="line">       <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//给当前线程分配hash值</span></span><br><span class="line">           ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">           <span class="comment">//取出当前线程的hash值 赋值给h</span></span><br><span class="line">           h = getProbe();</span><br><span class="line">           <span class="comment">//为什么wasUncontended设置为true？</span></span><br><span class="line">           <span class="comment">//代码执行到这里，说明线程没有分配hash值(hash=0)</span></span><br><span class="line">           <span class="comment">//所以 当前线程 肯定是写入到了 cells[0] 位置(0 &amp; 任意数 = 0)。 不把它当做一次真正的竞争</span></span><br><span class="line">           wasUncontended = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//表示扩容意向。 false 一定不会扩容；true 可能会扩容。</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//自旋</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">//as 表示cells引用</span></span><br><span class="line">           <span class="comment">//a 表示当前线程命中的cell</span></span><br><span class="line">           <span class="comment">//n 表示cells数组长度</span></span><br><span class="line">           <span class="comment">//v 表示 期望值</span></span><br><span class="line">           Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//CASE1： 表示cells已经初始化了，当前线程应该将数据写入到对应的cell中</span></span><br><span class="line">           <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//进入这个if，有下面两种情况</span></span><br><span class="line">               <span class="comment">//2.true-&gt; 说明当前线程对应下标的cell为空，需要创建 longAccumulate 支持</span></span><br><span class="line">               <span class="comment">//3.true-&gt;表示cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//CASE1.1：true-&gt;表示当前线程对应的下标位置的cell为null，需要创建new Cell</span></span><br><span class="line">               <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//true-&gt;表示当前锁 未被占用； false-&gt;表示锁被占用</span></span><br><span class="line">                   <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line"></span><br><span class="line">                       <span class="comment">//拿当前的x创建Cell</span></span><br><span class="line">                       <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line"></span><br><span class="line">                       <span class="comment">//条件一：true-&gt;表示当前锁 未被占用； false-&gt;表示锁被占用</span></span><br><span class="line">                       <span class="comment">//条件二：true-&gt;表示当前线程获取锁成功； false-&gt;当前线程获取锁失败。</span></span><br><span class="line">                       <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                           <span class="comment">//是否创建成功的标记</span></span><br><span class="line">                           <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                           <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                               <span class="comment">//rs 表示当前cells 引用</span></span><br><span class="line">                               <span class="comment">//m 表示cells长度</span></span><br><span class="line">                               <span class="comment">//j 表示当前线程命中的下标</span></span><br><span class="line">                               Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line"></span><br><span class="line">                               <span class="comment">//条件一 条件二 为true</span></span><br><span class="line">                               <span class="comment">//条件三：rs[j = (m - 1) &amp; h] == null 为了防止其它线程初始化过该位置，然后当前线程再次初始化该位置，导致丢失数据</span></span><br><span class="line">                               <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                       (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                       rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                   rs[j] = r;</span><br><span class="line">                                   created = <span class="literal">true</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                               cellsBusy = <span class="number">0</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">if</span> (created)</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//扩容意向 强制改为了false</span></span><br><span class="line">                   collide = <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// CASE1.2：true -&gt; wasUncontended：只有cells初始化之后，并且当前线程 竞争修改失败，才会是false</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                   wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">               <span class="comment">//CASE 1.3：当前线程rehash过hash值，然后新命中的cell不为空</span></span><br><span class="line">               <span class="comment">//true -&gt; 写成功,退出循环</span></span><br><span class="line">               <span class="comment">//false -&gt; 表示rehash之后命中的新的cell 也有竞争</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                       fn.applyAsLong(v, x))))</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="comment">//CASE 1.4：</span></span><br><span class="line">               <span class="comment">//条件一：n &gt;= NCPU 为 true-&gt;就会把扩容意向改为false，不再扩容； false-&gt; 说明cells数组还可以扩容</span></span><br><span class="line">               <span class="comment">//条件二：cells != as 为 true-&gt;其它线程已经扩容过了，当前线程rehash之后重试即可</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                   <span class="comment">//扩容意向为false，表示不扩容了</span></span><br><span class="line">                   collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">               <span class="comment">//CASE 1.5：</span></span><br><span class="line">               <span class="comment">//!collide == true 设置扩容意向 为true 但是不一定真的发生扩容</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                   collide = <span class="literal">true</span>;</span><br><span class="line">               <span class="comment">//CASE 1.6：真正扩容的逻辑</span></span><br><span class="line">               <span class="comment">//条件一：cellsBusy == 0 true-&gt;表示当前无锁状态，当前线程可以去竞争这把锁</span></span><br><span class="line">               <span class="comment">//条件二：casCellsBusy true-&gt;表示当前线程 获取锁 成功，可以执行扩容逻辑</span></span><br><span class="line">               <span class="comment">// false-&gt;表示当前时刻有其它线程在做扩容相关的操作。</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//这里又判断了一次cells == as。  防止其它线程已经扩容了，当前线程再次扩容。cells的引用就会发生变化，导致数据流失</span></span><br><span class="line">                       <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                           <span class="comment">//数组长度扩容，得到新数组，新长度等于旧长度左移1位，等价于 新长度=旧长度*2</span></span><br><span class="line">                           Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                           <span class="comment">//遍历旧数组，将旧数组对应位置的值放到新数组中</span></span><br><span class="line">                           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                               rs[i] = as[i];</span><br><span class="line">                           <span class="comment">//将新数组的引用赋值给全局的cells</span></span><br><span class="line">                           cells = rs;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">//释放锁</span></span><br><span class="line">                       cellsBusy = <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   collide = <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//修改失败，就会重置当前线程Hash值，然后当前线程自旋，再次修改时，就会到不同的cell上</span></span><br><span class="line">               h = advanceProbe(h);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CASE2：前置条件cells还未初始化，as 为null</span></span><br><span class="line">           <span class="comment">//条件一：true 表示当前未加锁</span></span><br><span class="line">           <span class="comment">//条件二：为什么cells == as？短路原则，当判断这个条件时，条件一为true，表示其他线程已经持有锁了</span></span><br><span class="line">           <span class="comment">//       那么其它线程在执行下面的初始化方法，可能会在你给as赋值为null之后修改了 cells，所以这里再判断一次</span></span><br><span class="line">           <span class="comment">//条件三：true 表示获取锁成功 会把cellsBusy = 1，false 表示其它线程正在持有这把锁</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">               <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                   <span class="comment">//这里又判断了一次cells == as。  防止其它线程已经初始化了，当前线程再次初始化 导致丢失数据</span></span><br><span class="line">                   <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                       Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                       rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                       cells = rs;</span><br><span class="line">                       init = <span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   cellsBusy = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (init)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CASE3：前面两个if中所有条件都为false才会执行到这，说明：</span></span><br><span class="line">           <span class="comment">//1.当前cellsBusy加锁状态，表示其它线程正在初始化cells，所以当前线程将值累加到base</span></span><br><span class="line">           <span class="comment">//2.cells被其它线程初始化后，当前线程需要将数据累加到base</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                   fn.applyAsLong(v, x))))</span><br><span class="line">               <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/concurrent/image/image_49.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                              <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">        <span class="comment">//(6) 初始化当前线程的变量threadLocalRandomProbe的值</span></span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">            h = getProbe();</span><br><span class="line">            wasUncontended = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;	<span class="comment">//(7)</span></span><br><span class="line">                <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;	<span class="comment">//(8)</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                        <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                                Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                cellsBusy = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                    wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">                <span class="comment">//当前Cell存在，则执行CAS设置（9）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                             fn.applyAsLong(v, x))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//当前Cells数组元素个数大于CPU个数（10）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                    collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                <span class="comment">//是否有冲突（11）</span></span><br><span class="line">                    collide = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果当前元素个数没有达到CPU个数并且有冲突则扩容（12）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                            Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                                rs[i] = as[i];</span><br><span class="line">                            cells = rs;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        cellsBusy = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//（13）为了能够找到一个空闲的Cell，重新计算hash值，xorshift算法生成随机数</span></span><br><span class="line">                h = advanceProbe(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//初始化Cell数组（14）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    	<span class="comment">//14.1</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                        <span class="comment">//14.2</span></span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                        cells = rs;</span><br><span class="line">                        init = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                        fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码很长很复杂，这里我们还是针对开头提出的问题3、问题4、问题5。</p>
<ul>
<li>问题3：如何初始化Cell数组？cells数组初始化是在代码（14）中进行的，cellsBusy是一个标示，为0说明当前cells数组没有在被初始化或者扩容，也没有在新建Cell元素（没有发生结构化改变），为1说明cells数组再被扩容、初始化或创建新的Cell元素，只有通过casCellsBusy()函数将cellsBusy变量成功由0设置为1才可继续初始化。然后就是申请数组空间，然后计算本线程要访问的cell下标，设置初始化标志，最后要重置cellsBusy标记。</li>
<li>问题4：Cell数组如何扩容？cells数组扩容是在代码（12）中进行的，对cells扩容是有条件的，也就是代码（10）（11）的条件都不满足，即当前cells的元素个数小于当前机器CPU个数并且当前多个线程访问了cells中同一个元素，从而导致冲突使其中一个线程CAS失败时才会进行扩容操作。因为最好让每个CPU只运行一个线程时效果最好，扩容也会进行casCellsBusy()操作。扩容后将原来的复制到新的数组中，剩余的还未初始化，为Null。</li>
<li>问题5：线程访问分配的Cell元素有冲突后如何处理？代码（7）（8）中，当前线程调用add方法并根据当前线程的随机数threadLocakRandomProbe和cells元素个数计算要访问的cell元素下标，然后如果发现对应下标元素的值为null，则新增一个Cell元素到cells数组，并且在将其添加到cells数组之前要竞争设置cellsBusy为1。代码（13）对CAS失败的线程重新计算当前线程的随机值threadLocalRandomProbe，以减少下次访问cells元素时的冲突机会。</li>
</ul>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。Unsafe 并不是指线程安全方面的不安全，而是指这个类比较底层，操作内存、线程，不建议我们编程人员直接对其使用，误用会导致不安全的发生，并不是指它本身是线程不安全的。前面介绍的所有的原子整数、原子引用这些原子类，它们的底层都是调用使用了 Unsafe，而 Unsafe 的底层调用了 CPU 的一些 cas 指令（以 lock 打头的一些指令）来保证比较和交换的原子性。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.baseUnsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeAccessor</span> &#123;</span><br><span class="line">    <span class="comment">// 这个对象普通获取不到 要通过反射获取</span></span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);<span class="comment">// 反射获取Unsafe类中的字段</span></span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);<span class="comment">// 因为这个字段是private的域,所以要设置权限为true</span></span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);<span class="comment">// 因为这个字段是static的从属于类的因此参数传递null 111</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> Student.class.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> Student.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> UnsafeAccessor.getUnsafe();</span><br><span class="line">        <span class="comment">// 获得成员变量的偏移量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">idOffset</span> <span class="operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(id);</span><br><span class="line">        <span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(name);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">// 使用cas方法替换成员变量的值</span></span><br><span class="line">        <span class="comment">// 新建好的对象还没赋过值 所以旧值默认为0和null</span></span><br><span class="line">        UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, <span class="number">0</span>, <span class="number">20</span>);<span class="comment">// 返回true</span></span><br><span class="line">        UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, <span class="literal">null</span>, <span class="string">&quot;迩东陈&quot;</span>);<span class="comment">// 返回true</span></span><br><span class="line">        System.out.println(student);</span><br><span class="line">        System.out.println(id.get(student));<span class="comment">// 因为这个字段不是static的,因此参数传递对象 222</span></span><br><span class="line">        System.out.println(name.get(student));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student(id=20, name=迩东陈)</span><br><span class="line">20</span><br><span class="line">迩东陈</span><br></pre></td></tr></table></figure>

<p>前面的取款案例，现在再使用底层的 Unsafe 来实现一次线程安全的原子操作。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.baseUnsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.AtomicData&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicData</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> DATA_OFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先获取unsafe</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);<span class="comment">//通过反射得到unsafe对象</span></span><br><span class="line">            <span class="comment">// 获取变量的偏移量</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">dataField</span> <span class="operator">=</span> AtomicData.class.getDeclaredField(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            DATA_OFFSET = unsafe.objectFieldOffset(dataField);<span class="comment">//得到data的偏移量</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);<span class="comment">//重点 一定注意！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicData</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//从主存中拿到共享变量的旧值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> data;</span><br><span class="line">            <span class="comment">//计算新值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">            <span class="comment">//cas 尝试修改 data 为 旧值 - amount，如果期间旧值被别的线程改了，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="built_in">this</span>, DATA_OFFSET, prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.concurrent.cas.baseUnsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">AtomicData</span> <span class="variable">atomicData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicData</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    atomicData.decrease(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(atomicData.getData() + <span class="string">&quot; cost:&quot;</span> + (endTime - startTime) / <span class="number">1000000</span> + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> cost:277ms</span><br></pre></td></tr></table></figure>

<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>CAS 与 volatile</li>
<li>API<ul>
<li>原子整数</li>
<li>原子引用</li>
<li>原子数组</li>
<li>字段更新器</li>
<li>原子累加器</li>
</ul>
</li>
<li>Unsafe</li>
<li>原理方面<ul>
<li>LongAdder源码</li>
<li>伪共享</li>
</ul>
</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>共享模型之无锁</p><p><a href="https://chanservy.github.io/posts/20211122/java-concurrent-4.html">https://chanservy.github.io/posts/20211122/java-concurrent-4.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>迩东陈</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-11-22</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-08-31</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> CC BY-NC-SA 4.0</a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程 </a></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/20211123/java-concurrent-5.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">共享模型之不可变</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/20211121/java-concurrent-3.html"><span class="level-item">共享模型之内存</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "f7IR3RHtvyy3zbMnkj08F4Uv-gzGzoHsz",
            appKey: "ztlhTLYlXtUClUWYAQBB5h1U",
            
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/head/head.jpg" alt="ChanServy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ChanServy</p><p class="is-size-6 is-block">1579700161@qq.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>LiaoNing, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives/"><div><p class="heading">文章</p><div><p class="title">16</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/categories/"><div><p class="heading">分类</p><div><p class="title">6</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/tags/"><div><p class="heading">标签</p><div><p class="title">10</p></div></div></a></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/erdochan" target="_blank" rel="noopener"><i class="fab fa-github"></i>  关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#取款案例"><span class="level-left"><span class="level-item">1</span><span class="level-item">取款案例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#不安全实现"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">不安全实现</span></span></a></li><li><a class="level is-mobile" href="#解决思路：-锁"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">解决思路： 锁</span></span></a></li><li><a class="level is-mobile" href="#解决思路：-无锁"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">解决思路： 无锁</span></span></a></li></ul></li><li><a class="level is-mobile" href="#CAS-与-volatile"><span class="level-left"><span class="level-item">2</span><span class="level-item">CAS 与 volatile</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#volatile"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">volatile</span></span></a></li><li><a class="level is-mobile" href="#为什么无锁效率高"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">为什么无锁效率高</span></span></a></li><li><a class="level is-mobile" href="#CAS-的特点"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">CAS 的特点</span></span></a></li></ul></li><li><a class="level is-mobile" href="#原子整数"><span class="level-left"><span class="level-item">3</span><span class="level-item">原子整数</span></span></a></li><li><a class="level is-mobile" href="#原子引用"><span class="level-left"><span class="level-item">4</span><span class="level-item">原子引用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#不安全实现-1"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">不安全实现</span></span></a></li><li><a class="level is-mobile" href="#解决思路：-锁-1"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">解决思路： 锁</span></span></a></li><li><a class="level is-mobile" href="#解决思路：-无锁-1"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">解决思路： 无锁</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ABA-问题及解决"><span class="level-left"><span class="level-item">5</span><span class="level-item">ABA 问题及解决</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ABA-问题"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">ABA 问题</span></span></a></li><li><a class="level is-mobile" href="#AtomicStampedReference"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">AtomicStampedReference</span></span></a></li><li><a class="level is-mobile" href="#AtomicMarkableReference"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">AtomicMarkableReference</span></span></a></li></ul></li><li><a class="level is-mobile" href="#原子数组"><span class="level-left"><span class="level-item">6</span><span class="level-item">原子数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#不安全的数组"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">不安全的数组</span></span></a></li><li><a class="level is-mobile" href="#安全的数组"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">安全的数组</span></span></a></li></ul></li><li><a class="level is-mobile" href="#字段更新器"><span class="level-left"><span class="level-item">7</span><span class="level-item">字段更新器</span></span></a></li><li><a class="level is-mobile" href="#原子累加器"><span class="level-left"><span class="level-item">8</span><span class="level-item">原子累加器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#累加器性能比较"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">累加器性能比较</span></span></a></li><li><a class="level is-mobile" href="#性能提升的原因"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">性能提升的原因</span></span></a></li><li><a class="level is-mobile" href="#LongAdder源码剖析"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">LongAdder源码剖析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#cas-锁-demo"><span class="level-left"><span class="level-item">8.3.1</span><span class="level-item">cas 锁 demo</span></span></a></li><li><a class="level is-mobile" href="#LongAdder-源码分析"><span class="level-left"><span class="level-item">8.3.2</span><span class="level-item">LongAdder 源码分析</span></span></a></li><li><a class="level is-mobile" href="#原理之伪共享"><span class="level-left"><span class="level-item">8.3.3</span><span class="level-item">原理之伪共享</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Unsafe"><span class="level-left"><span class="level-item">9</span><span class="level-item">Unsafe</span></span></a></li><li><a class="level is-mobile" href="#本章小结"><span class="level-left"><span class="level-item">10</span><span class="level-item">本章小结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/icarus-favicon.svg" alt="迩东陈" height="28"></a><p class="is-size-7"><span>&copy; 2022 迩东陈</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="ChanServy GitHub" href="https://github.com/ChanServy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>