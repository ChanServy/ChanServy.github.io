<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>RabbitMQ学习记录 - 迩东陈</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="迩东陈"><meta name="msapplication-TileImage" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/head/star.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="迩东陈"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="RabbitMQ-基础篇初识MQ同步和异步通讯微服务间通讯有同步和异步两种方式： 同步通讯：就像打电话，需要实时响应。 异步通讯：就像发邮件，不需要马上回复。  两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。"><meta property="og:type" content="blog"><meta property="og:title" content="RabbitMQ学习记录"><meta property="og:url" content="https://chanservy.github.io/posts/20220622/rabbitmq-study.html"><meta property="og:site_name" content="迩东陈"><meta property="og:description" content="RabbitMQ-基础篇初识MQ同步和异步通讯微服务间通讯有同步和异步两种方式： 同步通讯：就像打电话，需要实时响应。 异步通讯：就像发邮件，不需要马上回复。  两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717161939695.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717162004285.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210422095356088.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717162752376.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717163332646.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717163434647.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717164024967.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717164038678.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717164238910.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165309625.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165438225.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165509466.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165552676.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170041447.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170223317.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170705380.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170829229.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20200525170410401.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210422232835363.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718155003157.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718155059371.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718160907166.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718161707992.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718164412450.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718164729543.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718165100016.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718171705383.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718171759179.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718172746378.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174328383.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174416160.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174506856.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210821073801398.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174506856.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718182643311.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/2022-06-24_22-05.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718191657478.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718191738706.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718192529342.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718193747649.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718193831076.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718193917009.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718194040498.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718194522223.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718194539054.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718220843323.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718221039542.png"><meta property="article:published_time" content="2022-06-22T14:08:12.000Z"><meta property="article:modified_time" content="2022-08-31T08:06:20.587Z"><meta property="article:author" content="迩东陈"><meta property="article:tag" content="RabbitMQ"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717161939695.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://chanservy.github.io/posts/20220622/rabbitmq-study.html"},"headline":"RabbitMQ学习记录","image":["https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717161939695.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717162004285.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210422095356088.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717162752376.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717163332646.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717163434647.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717164024967.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717164038678.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717164238910.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165309625.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165438225.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165509466.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165552676.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170041447.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170223317.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170705380.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170829229.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20200525170410401.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210422232835363.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718155003157.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718155059371.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718160907166.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718161707992.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718164412450.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718164729543.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718165100016.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718171705383.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718171759179.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718172746378.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174328383.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174416160.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174506856.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210821073801398.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174506856.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718182643311.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/2022-06-24_22-05.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718191657478.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718191738706.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718192529342.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718193747649.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718193831076.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718193917009.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718194040498.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718194522223.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718194539054.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718220843323.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718221039542.png"],"datePublished":"2022-06-22T14:08:12.000Z","dateModified":"2022-08-31T08:06:20.587Z","author":{"@type":"Person","name":"迩东陈"},"publisher":{"@type":"Organization","name":"迩东陈","logo":{"@type":"ImageObject","url":"https://chanservy.github.io/img/icarus-favicon.svg"}},"description":"RabbitMQ-基础篇初识MQ同步和异步通讯微服务间通讯有同步和异步两种方式： 同步通讯：就像打电话，需要实时响应。 异步通讯：就像发邮件，不需要马上回复。  两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。"}</script><link rel="canonical" href="https://chanservy.github.io/posts/20220622/rabbitmq-study.html"><link rel="icon" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/head/star.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/icarus-favicon.svg" alt="迩东陈" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives/">Archives</a><a class="navbar-item" href="/categories/">Categories</a><a class="navbar-item" href="/tags/">Tags</a><a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="ChanServy GitHub" href="https://github.com/ChanServy"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>RabbitMQ学习记录</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2022-06-22T14:08:12.000Z" title="2022-06-22T14:08:12.000Z">2022-06-22</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2022-08-31T08:06:20.587Z" title="2022-08-31T08:06:20.587Z">2022-08-31</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></span><span class="level-item"><i class="far fa-clock"></i> 2 小时读完 (大约15569个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><h1 id="RabbitMQ-基础篇"><a href="#RabbitMQ-基础篇" class="headerlink" title="RabbitMQ-基础篇"></a>RabbitMQ-基础篇</h1><h2 id="初识MQ"><a href="#初识MQ" class="headerlink" title="初识MQ"></a>初识MQ</h2><h3 id="同步和异步通讯"><a href="#同步和异步通讯" class="headerlink" title="同步和异步通讯"></a>同步和异步通讯</h3><p>微服务间通讯有同步和异步两种方式：</p>
<p>同步通讯：就像打电话，需要实时响应。</p>
<p>异步通讯：就像发邮件，不需要马上回复。</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717161939695.png" alt="image-20210717161939695"></p>
<p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p>
<span id="more"></span>

<h4 id="同步通讯"><a href="#同步通讯" class="headerlink" title="同步通讯"></a>同步通讯</h4><p>我们熟知的微服务间通信Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717162004285.png" alt="image-20210717162004285"></p>
<p>总结：</p>
<p>同步调用的优点：</p>
<ul>
<li>时效性较强，可以立即得到结果</li>
</ul>
<p>同步调用的问题：</p>
<ul>
<li>耦合度高</li>
<li>性能和吞吐能力下降</li>
<li>有额外的资源消耗</li>
<li>有级联失败问题</li>
</ul>
<h4 id="异步通讯"><a href="#异步通讯" class="headerlink" title="异步通讯"></a>异步通讯</h4><p>异步调用则可以避免上述问题：</p>
<p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p>
<p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p>
<p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p>
<p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210422095356088.png" alt="image-20210422095356088"></p>
<p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>
<p>好处：</p>
<ul>
<li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p>
</li>
<li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p>
</li>
<li><p>调用间没有阻塞，不会造成无效的资源占用</p>
</li>
<li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p>
</li>
<li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>架构复杂了，业务没有明显的流程线，不好管理</li>
<li>需要依赖于Broker的可靠、安全、性能</li>
</ul>
<p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p>
<h3 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h3><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p>
<p>比较常见的MQ实现：</p>
<ul>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>RocketMQ</li>
<li>Kafka</li>
</ul>
<p>几种常见MQ的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公司&#x2F;社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire,STOMP，REST,XMPP,AMQP</td>
<td>自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td>可用性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>一般</td>
<td>差</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody></table>
<p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p>
<p>追求可靠性：RabbitMQ、RocketMQ</p>
<p>追求吞吐能力：RocketMQ、Kafka</p>
<p>追求消息低延迟：RabbitMQ、Kafka</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h3><p><a target="_blank" rel="noopener" href="https://chanservy.vercel.app/posts/20220622/rabbitmq-install.html">https://chanservy.vercel.app/posts/20220622/rabbitmq-install.html</a></p>
<p>MQ的基本结构：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717162752376.png" alt="image-20210717162752376"></p>
<p>RabbitMQ中的一些角色：</p>
<ul>
<li>publisher：生产者</li>
<li>consumer：消费者</li>
<li>exchange：交换机，负责消息路由</li>
<li>queue：队列，存储消息</li>
<li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li>
</ul>
<h3 id="RabbitMQ消息模型"><a href="#RabbitMQ消息模型" class="headerlink" title="RabbitMQ消息模型"></a>RabbitMQ消息模型</h3><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717163332646.png" alt="image-20210717163332646"></p>
<h3 id="Demo案例"><a href="#Demo案例" class="headerlink" title="Demo案例"></a>Demo案例</h3><p>案例代码地址：<a target="_blank" rel="noopener" href="https://github.com/ChanServy/rabbitmq-advanced">https://github.com/ChanServy/rabbitmq-advanced</a></p>
<p>包括三部分：</p>
<ul>
<li>mq-demo：父工程，管理项目依赖</li>
<li>publisher：消息的发送者</li>
<li>consumer：消息的消费者</li>
<li>common：公共模块</li>
</ul>
<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p>简单队列模式的模型图：</p>
<p> <img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717163434647.png" alt="image-20210717163434647"></p>
<p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<ul>
<li>publisher：消息发布者，将消息发送到队列queue</li>
<li>queue：消息队列，负责接受并缓存消息</li>
<li>consumer：订阅队列，处理队列中的消息</li>
</ul>
<h4 id="publisher实现"><a href="#publisher实现" class="headerlink" title="publisher实现"></a>publisher实现</h4><p>思路：</p>
<ul>
<li>建立连接</li>
<li>创建Channel</li>
<li>声明队列</li>
<li>发送消息</li>
<li>关闭连接和channel</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="consumer实现"><a href="#consumer实现" class="headerlink" title="consumer实现"></a>consumer实现</h4><p>代码思路：</p>
<ul>
<li>建立连接</li>
<li>创建Channel</li>
<li>声明队列</li>
<li>订阅消息</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本消息队列的消息发送流程：</p>
<ol>
<li><p>建立connection</p>
</li>
<li><p>创建channel</p>
</li>
<li><p>利用channel声明队列</p>
</li>
<li><p>利用channel向队列发送消息</p>
</li>
</ol>
<p>基本消息队列的消息接收流程：</p>
<ol>
<li><p>建立connection</p>
</li>
<li><p>创建channel</p>
</li>
<li><p>利用channel声明队列</p>
</li>
<li><p>定义consumer的消费行为handleDelivery()</p>
</li>
<li><p>利用channel将消费者与队列绑定</p>
</li>
</ol>
<h2 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h2><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p>
<p>SpringAmqp的官方地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717164024967.png" alt="image-20210717164024967"></p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717164038678.png" alt="image-20210717164038678"></p>
<p>SpringAMQP提供了三个功能：</p>
<ul>
<li>自动声明队列、交换机及其绑定关系</li>
<li>基于注解的监听器模式，异步接收消息</li>
<li>封装了RabbitTemplate工具，用于发送消息</li>
</ul>
<h3 id="Basic-Queue-简单队列模型"><a href="#Basic-Queue-简单队列模型" class="headerlink" title="Basic Queue 简单队列模型"></a>Basic Queue 简单队列模型</h3><p>在父工程中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>



<p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * basic queue 简单队列模型</span></span><br><span class="line"><span class="comment">     * 利用RabbitTemplate实现向指定队列中发送消息。</span></span><br><span class="line"><span class="comment">     * 一个生产者向队列中推送消息，一个消费者监听队列消费消息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simple&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">simpleSendToQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setName(<span class="string">&quot;蛤蟆先生去看心理医生&quot;</span>);</span><br><span class="line">        book.setAuthor(<span class="string">&quot;罗伯特&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">bookJson</span> <span class="operator">=</span> JSONUtil.toJsonStr(book);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>, bookJson);</span><br><span class="line">        <span class="keyword">return</span> R.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h4><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>



<p>新建一个类SimpleQueueListener，代码如下：</p>
<p>注：@RabbitListener注解监听的队列在MQ服务器中如果不存在，会报错。</p>
<p>发送消息，如果发送的消息是个对象，我们会使用序列化机制将对象写出去，对象必须实现 Serializable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者消费者服务间传递的消息是对象时，对象的引用路径必须一致</span></span><br><span class="line"><span class="comment"> * 这样就得将这个对象抽取出来放到公共模块</span></span><br><span class="line"><span class="comment"> * 如果不这样，那么在发送消息之前，生产者可以将这个对象变成JSON字符串</span></span><br><span class="line"><span class="comment"> * 然后再发送，那么在消费者收到消息之后，需要将JSON字符串再转成对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/7/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.mq.consumer.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chan.mq.common.pojo.Book;</span><br><span class="line"><span class="keyword">import</span> com.chan.mq.common.pojo.Movie;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听消息：使用<span class="doctag">@RabbitListener</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RabbitListener</span> ：加在类或者方法上（监听哪些队列即可）queues：声明需要监听的所有队列。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RabbitHandler</span> ：加在方法上（区分不同类型的消息）</span></span><br><span class="line"><span class="comment"> * 区分的不同类型消息：</span></span><br><span class="line"><span class="comment"> * 可能是listener监听两个队列的消息，两个队列中的消息类型可能不同，String、Book。</span></span><br><span class="line"><span class="comment"> * 也可能是listener监听一个队列中的消息，发送到这个队列的多条消息类型可能不同，String、Book。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/7/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// @RabbitListener(queues = &#123;&quot;simple.queue&quot;, &quot;work.queue&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;simple.queue&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleQueueListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听simple.queue队列中的消息，如果simple.queue不存在会报错。</span></span><br><span class="line"><span class="comment">     * // <span class="doctag">@RabbitListener</span>(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="comment">     * // public void listenSimpleQueueMessage(String msg) throws InterruptedException &#123;</span></span><br><span class="line"><span class="comment">     * //     System.out.println(&quot;spring 消费者接收到消息：【&quot; + msg + &quot;】&quot;);</span></span><br><span class="line"><span class="comment">     * // &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到String类型的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到Book类型的消息：【&quot;</span> + book + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@RabbitListener ：加在类或者方法上，queues：声明需要监听的所有队列。</li>
<li>@RabbitHandler ：加在方法上（区分不同类型的消息）</li>
<li>区分的不同类型消息：<ul>
<li>可能是listener监听两个队列的消息，两个队列中的消息类型可能不同，String、Book。</li>
<li>也可能是listener监听一个队列中的消息，发送到这个队列的多条消息类型可能不同，String、Book。</li>
</ul>
</li>
</ul>
<ul>
<li>参数可以写以下类型：<ul>
<li>1、Message message：原生消息详细信息。头 + 体</li>
<li>2、T&lt;发送的消息的类型&gt; ：例如 Book</li>
<li>3、Channel channel：当前传输数据的通道。注：如果消费者需要手动 ACK，那么就得传 channel，channel 可以调用相关 API。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Queue：可以多个消费者都来监听，只要消息被收到，队列删除消息，而且在正常情况下，同一条消息只能有一个消费者收到。</p>
<p>场景：</p>
<ul>
<li>订单服务启动多个，但是对于同一条消息只能有一个客户端收到。</li>
<li>只有一个消息完全处理完，方法运行结束，我们才可以接收到下一条消息。</li>
</ul>
</blockquote>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。</p>
<blockquote>
<p>注意：</p>
<p>RabbitMQ一共五种消息队列。基本消息队列和工作消息队列的情况下，生产者是直接向队列中发送消息，消费者监听队列就可以。创建队列的代码写在消费者微服务里面，生产者服务只需要知道队列的名字，发送消息时指定队列名和消息就可以。创建队列的方式我们使用@Bean的方式。</p>
<p>在广播（Fanout）、路由（Direct）、主题（Topic）的情况下，生产者是向交换机（Exchange）中发送消息，然后绑定队列和交换机，绑定之后交换机将消息传递给队列，消费者依然是监听队列。创建交换机、队列以及绑定的代码写在消费者微服务里面，生产者服务需要知道交换机的名字、交换机和队列间传递消息的routing key，发送消息时指定交换机名和key就可以。创建交换机、队列以及绑定的代码我们可以使用@Bean的方式，也可以直接在@RabbitListener注解中声明交换机并指定交换机类型、队列以及绑定关系。</p>
</blockquote>
<h3 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h3><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717164238910.png" alt="image-20210717164238910"></p>
<p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p>
<p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p>
<h4 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h4><p>这次我们循环发送，模拟大量消息堆积现象。</p>
<p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WorkQueues，也被称为（Task queues），任务模型</span></span><br><span class="line"><span class="comment"> * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment"> * 一个生产者向队列中推送消息，让多个消费者绑定到一个队列，共同消费队列中的消息。避免消息堆积。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;work.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="消息接收-1"><a href="#消息接收-1" class="headerlink" title="消息接收"></a>消息接收</h4><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的WorkQueueListener中添加2个新的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkQueueListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;消费者2......接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到这个消费者sleep了200毫秒，模拟任务耗时，两个消费者任务耗时不一致。</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p>
<p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p>
<p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p>
<h4 id="能者多劳"><a href="#能者多劳" class="headerlink" title="能者多劳"></a>能者多劳</h4><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure>



<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>Work模型的使用：</p>
<ul>
<li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li>
<li>通过设置prefetch来控制消费者预取的消息数量</li>
</ul>
<h3 id="发布-x2F-订阅"><a href="#发布-x2F-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h3><p>发布订阅的模型如图：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165309625.png" alt="image-20210717165309625"></p>
<p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p>
<ul>
<li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给交换机</li>
<li>Exchange：交换机。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul>
<li>Fanout：广播，将消息交给所有绑定到交换机的队列</li>
<li>Direct：定向，把消息交给符合指定routing key 的队列</li>
<li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li>
</ul>
</li>
<li>Consumer：消费者，与以前一样，订阅队列，没有变化</li>
<li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li>
</ul>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h3 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h3><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165438225.png" alt="image-20210717165438225"></p>
<p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>1）  可以有多个队列</li>
<li>2）  每个队列都要绑定到Exchange（交换机）</li>
<li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li>
<li>4）  交换机把消息发送给绑定过的所有队列</li>
<li>5）  订阅队列的消费者都能拿到消息</li>
</ul>
<p>我们的计划是这样的：</p>
<ul>
<li>创建一个交换机 itcast.fanout，类型是Fanout</li>
<li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li>
</ul>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165509466.png" alt="image-20210717165509466"></p>
<h4 id="声明队列和交换机"><a href="#声明队列和交换机" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h4><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717165552676.png" alt="image-20210717165552676"></p>
<p>在consumer中创建一个类，声明队列和交换机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/7/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机，默认情况下，由SpringAMQP声明的交换机都是持久化的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanout.exchange&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，由SpringAMQP声明的队列都是持久化的。</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用QueueBuilder构建队列，durable就是持久化的</span></span><br><span class="line">        <span class="comment">// return QueueBuilder.durable(&quot;fanout.queue1&quot;).build();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="消息发送-2"><a href="#消息发送-2" class="headerlink" title="消息发送"></a>消息发送</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/fanout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">fanoutSendToExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;fanout.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, Rabbit FanoutExchange!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="消息接收-2"><a href="#消息接收-2" class="headerlink" title="消息接收"></a>消息接收</h4><p>在consumer服务的WithExchangeListener中添加两个方法，作为消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/7/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithExchangeListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;<span class="comment">// test error msg</span></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>交换机的作用是什么？</p>
<ul>
<li>接收publisher发送的消息</li>
<li>将消息按照规则路由到与之绑定的队列</li>
<li>不能缓存消息，路由失败，消息丢失</li>
<li>FanoutExchange的会将消息路由到每个绑定的队列</li>
</ul>
<p>声明队列、交换机、绑定关系的Bean是什么？</p>
<ul>
<li>Queue</li>
<li>FanoutExchange</li>
<li>Binding</li>
</ul>
<h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h3><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170041447.png" alt="image-20210717170041447"></p>
<p> 在Direct模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li>
<li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li>
</ul>
<p><strong>案例需求如下</strong>：</p>
<ol>
<li><p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p>
</li>
<li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p>
</li>
<li><p>在publisher中编写测试方法，向itcast. direct发送消息</p>
</li>
</ol>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170223317.png" alt="image-20210717170223317"></p>
<h4 id="基于注解声明队列和交换机"><a href="#基于注解声明队列和交换机" class="headerlink" title="基于注解声明队列和交换机"></a>基于注解声明队列和交换机</h4><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p>
<p>在consumer的WithExchangeListener中添加两个消费者，同时基于注解来声明队列和交换机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面的fanout类型的交换机测试的时候我们是使用@Bean的方式创建的交换机和队列以及绑定关系，下面使用注解的方式</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;direct.exchange&quot;, type = ExchangeTypes.DIRECT/*交换机类型默认DIRECT*/),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;direct.exchange&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="消息发送-3"><a href="#消息发送-3" class="headerlink" title="消息发送"></a>消息发送</h4><p>在publisher服务中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/direct&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">directSendToExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;direct.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;blue&quot;</span>, message);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>描述下Direct交换机与Fanout交换机的差异？</p>
<ul>
<li>Fanout交换机将消息路由给每一个与之绑定的队列</li>
<li>Direct交换机根据RoutingKey判断路由给哪个队列</li>
<li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li>
</ul>
<p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p>
<ul>
<li>@Queue</li>
<li>@Exchange</li>
</ul>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p>
<p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<p><code>#</code>：匹配一个或多个词</p>
<p><code>*</code>：匹配不多不少恰好1个词</p>
<p>举例：</p>
<p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p>
<p><code>item.*</code>：只能匹配<code>item.spu</code></p>
<p>​     </p>
<p>图示：</p>
<p> <img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170705380.png" alt="image-20210717170705380"></p>
<p>解释：</p>
<ul>
<li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li>
<li>Queue4：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li>
</ul>
<p>案例需求：</p>
<p>实现思路如下：</p>
<ol>
<li><p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p>
</li>
<li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p>
</li>
<li><p>在publisher中编写测试方法，向itcast. topic发送消息</p>
</li>
</ol>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210717170829229.png" alt="image-20210717170829229"></p>
<h4 id="消息发送-4"><a href="#消息发送-4" class="headerlink" title="消息发送"></a>消息发送</h4><p>在publisher服务中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/topic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">topicSendToExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;topic.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="消息接收-3"><a href="#消息接收-3" class="headerlink" title="消息接收"></a>消息接收</h4><p>在consumer服务的WithExchangeListener中添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;topic.exchange&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;topic.exchange&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>描述下Direct交换机与Topic交换机的差异？</p>
<ul>
<li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li>
<li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li>
<li><code>#</code>：代表0个或多个词</li>
<li><code>*</code>：代表1个词</li>
</ul>
<h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ（前提是对象类型实现序列化接口），接收消息的时候，还会把字节反序列化为Java对象。</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20200525170410401.png" alt="image-20200525170410401"></p>
<p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大</li>
<li>有安全漏洞</li>
<li>可读性差</li>
</ul>
<p>我们来测试一下。</p>
<h4 id="测试默认转换器"><a href="#测试默认转换器" class="headerlink" title="测试默认转换器"></a>测试默认转换器</h4><p>我们修改消息发送的代码，发送一个Map对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>,<span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>停止consumer服务</p>
<p>发送消息后查看控制台：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210422232835363.png" alt="image-20210422232835363"></p>
<h4 id="配置JSON转换器"><a href="#配置JSON转换器" class="headerlink" title="配置JSON转换器"></a>配置JSON转换器</h4><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p>
<p>在publisher和consumer两个服务中都引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置消息转换器。</p>
<p>在启动类中添加一个Bean即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我个人还是更倾向于自己手动将对象类型转成一个JSON字符串，然后再发送到MQ Server，消费者接收JSON字符串后再手动转成对象。不想用这个。</p>
<h1 id="服务异步通信-高级篇"><a href="#服务异步通信-高级篇" class="headerlink" title="服务异步通信-高级篇"></a>服务异步通信-高级篇</h1><p>消息队列在使用过程中，面临着很多实际问题需要思考：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718155003157.png" alt="image-20210718155003157"></p>
<h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><p>消息从发送，到消费者接收，会经理多个过程：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718155059371.png" alt="image-20210718155059371"></p>
<p>其中的每一步都可能导致消息丢失，常见的丢失原因包括：</p>
<ul>
<li>发送时丢失：<ul>
<li>生产者发送的消息未送达exchange</li>
<li>消息到达exchange后未到达queue</li>
</ul>
</li>
<li>MQ宕机，queue将消息丢失</li>
<li>consumer接收到消息后未消费就宕机</li>
</ul>
<p>针对这些问题，RabbitMQ分别给出了解决方案：</p>
<ul>
<li>生产者确认机制</li>
<li>mq持久化</li>
<li>消费者确认机制</li>
<li>失败重试机制</li>
</ul>
<p>下面通过案例来演示每一个步骤。案例代码地址：<a target="_blank" rel="noopener" href="https://github.com/ChanServy/rabbitmq-advanced">https://github.com/ChanServy/rabbitmq-advanced</a></p>
<h3 id="生产者消息确认"><a href="#生产者消息确认" class="headerlink" title="生产者消息确认"></a>生产者消息确认</h3><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。</p>
<p>返回结果有两种方式：</p>
<ul>
<li>publisher-confirm，发送者确认<ul>
<li>消息成功投递到交换机，返回ack</li>
<li>消息未投递到交换机，返回nack</li>
</ul>
</li>
<li>publisher-return，发送者回执<ul>
<li>消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。</li>
</ul>
</li>
</ul>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718160907166.png" alt="image-20210718160907166"></p>
<p>注意：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718161707992.png" alt="image-20210718161707992"></p>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>首先，修改publisher服务中的application.yml文件，添加下面的内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>publish-confirm-type</code>：开启publisher-confirm，这里支持两种类型：<ul>
<li><code>simple</code>：同步等待confirm结果，直到超时</li>
<li><code>correlated</code>：异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback</li>
</ul>
</li>
<li><code>publish-returns</code>：开启publish-return功能，同样是基于callback机制，不过是定义ReturnCallback</li>
<li><code>template.mandatory</code>：定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息</li>
</ul>
<h4 id="定义Return回调"><a href="#定义Return回调" class="headerlink" title="定义Return回调"></a>定义Return回调</h4><p>每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目加载时配置：</p>
<p>修改publisher服务，添加一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.mq.producer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目加载时配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/7/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Bean</span></span><br><span class="line">    <span class="comment">// public MessageConverter messageConverter() &#123;</span></span><br><span class="line">    <span class="comment">//     return new Jackson2JsonMessageConverter();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取RabbitTemplate</span></span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        <span class="comment">// 设置ReturnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断是否是延迟消息</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">receivedDelay</span> <span class="operator">=</span> message.getMessageProperties().getReceivedDelay();</span><br><span class="line">            <span class="keyword">if</span> (receivedDelay != <span class="literal">null</span> &amp;&amp; receivedDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 是一个延迟消息，忽略这个错误提示</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 投递失败，记录日志</span></span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由键&#123;&#125;,消息&#123;&#125;&quot;</span>,</span><br><span class="line">                    replyCode, replyText, exchange, routingKey, message.toString());</span><br><span class="line">            <span class="comment">// 如果有业务需要，可以重发消息</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h4><p>ConfirmCallback可以在发送消息时指定，因为每个业务处理confirm成功或失败的逻辑不一定相同。</p>
<p>common服务中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在publisher服务中，定义一个测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">testSendWithConfirmCallback</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 消息体</span></span><br><span class="line">    <span class="type">Movie</span> <span class="variable">movie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>();</span><br><span class="line">    movie.setId(<span class="number">1</span>);</span><br><span class="line">    movie.setName(<span class="string">&quot;复仇者联盟&quot;</span>);</span><br><span class="line">    movie.setAuthor(<span class="string">&quot;漫威&quot;</span>);</span><br><span class="line">    <span class="comment">// String movieJson = JSONUtil.toJsonStr(movie);</span></span><br><span class="line">    <span class="comment">// 全局唯一的消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(String.valueOf(movie.getId()));</span><br><span class="line">    <span class="comment">// 添加callback</span></span><br><span class="line">    correlationData.getFuture().addCallback(</span><br><span class="line">        result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断结果</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.requireNonNull(result).isAck()) &#123;</span><br><span class="line">                <span class="comment">// ACK</span></span><br><span class="line">                log.debug(<span class="string">&quot;消息成功投递到交换机！消息ID: &#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// NACK</span></span><br><span class="line">                log.error(<span class="string">&quot;消息投递到交换机失败！消息ID：&#123;&#125;，原因：&#123;&#125;&quot;</span>, correlationData.getId(), result.getReason());</span><br><span class="line">                <span class="comment">// 重发消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        exception -&gt; &#123;</span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">            log.error(<span class="string">&quot;消息发送异常, 消息ID：&#123;&#125;，原因：&#123;&#125;&quot;</span>, correlationData.getId(), exception.getMessage());</span><br><span class="line">            <span class="comment">// 重发消息...</span></span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>, movie, correlationData);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;simple.queue&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleQueueListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Movie movie, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到Movie类型的消息：【&quot;</span> + movie + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();<span class="comment">// 获取消息体</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">properties</span> <span class="operator">=</span> message.getMessageProperties();<span class="comment">// 获取消息头属性信息</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> properties.getDeliveryTag();<span class="comment">// channel内按顺序自增的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;deliveryTag===&gt;&quot;</span> + deliveryTag);</span><br><span class="line">        channel.basicAck(deliveryTag, <span class="literal">false</span>);<span class="comment">// 消费者手动ACK，false：只手动ACK当前这条消息</span></span><br><span class="line">        <span class="comment">// requeue=false 丢弃；requeue=true 重新发回MQ服务器，重新入队</span></span><br><span class="line">        channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">false</span>);<span class="comment">// 消费者手动NACK，false：只手动NACK当前这条消息，false：设置NACK这条消息不重新入队</span></span><br><span class="line">        channel.basicReject(deliveryTag, <span class="literal">false</span>);<span class="comment">// 和NACK1个意思，只不过不能设置批量参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数可以写以下类型：</p>
<ul>
<li>1、Message message：原生消息详细信息。头 + 体</li>
<li>2、T&lt;发送的消息的类型&gt; ：例如 Book</li>
<li>3、Channel channel：当前传输数据的通道。注：如果消费者需要手动 ACK，那么就得传 channel，channel 可以调用相关 API。</li>
</ul>
<p>后面详细说消费者端消息安全性的问题。</p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>生产者确认可以确保消息投递到RabbitMQ的队列中，但是消息发送到RabbitMQ以后，如果突然宕机，也可能导致消息丢失。</p>
<p>要想确保消息在RabbitMQ中安全保存，必须开启消息持久化机制。</p>
<ul>
<li>交换机持久化</li>
<li>队列持久化</li>
<li>消息持久化</li>
</ul>
<h4 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h4><p>RabbitMQ中交换机默认是非持久化的，mq重启后就丢失。</p>
<p>SpringAMQP中可以通过代码指定交换机持久化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">simpleExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;simple.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由SpringAMQP声明的交换机都是持久化的。</p>
<p>可以在RabbitMQ控制台看到持久化的交换机都会带上<code>D</code>的标示：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718164412450.png" alt="image-20210718164412450"></p>
<h4 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h4><p>RabbitMQ中队列默认是非持久化的，mq重启后就丢失。</p>
<p>SpringAMQP中可以通过代码指定交换机持久化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">simpleQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 使用QueueBuilder构建队列，durable就是持久化的</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由SpringAMQP声明的队列都是持久化的。</p>
<p>可以在RabbitMQ控制台看到持久化的队列都会带上<code>D</code>的标示：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718164729543.png" alt="image-20210718164729543"></p>
<h4 id="消息持久化-1"><a href="#消息持久化-1" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>利用SpringAMQP发送消息时，可以设置消息的属性（MessageProperties），指定delivery-mode：</p>
<ul>
<li>1：非持久化</li>
<li>2：持久化</li>
</ul>
<p>用java代码指定：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718165100016.png" alt="image-20210718165100016"></p>
<p>默认情况下，SpringAMQP发出的任何消息都是持久化的，不用特意指定。</p>
<h3 id="消费者消息确认"><a href="#消费者消息确认" class="headerlink" title="消费者消息确认"></a>消费者消息确认</h3><p>RabbitMQ是<strong>阅后即焚</strong>机制，RabbitMQ确认消息被消费者消费后会立刻删除。</p>
<p>而RabbitMQ是通过消费者回执来确认消费者是否成功处理消息的：消费者获取消息后，应该向RabbitMQ发送ACK回执，表明自己已经处理消息。</p>
<p>设想这样的场景：</p>
<ul>
<li>1）RabbitMQ投递消息给消费者</li>
<li>2）消费者获取消息后，返回ACK给RabbitMQ</li>
<li>3）RabbitMQ删除消息</li>
<li>4）消费者宕机，消息尚未处理</li>
</ul>
<p>这样，消息就丢失了。因此消费者返回ACK的时机非常重要。</p>
<p>而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li>manual：手动ack，需要在业务代码结束后，调用api发送ack。</li>
<li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</li>
<li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li>
</ul>
<p>由此可知：</p>
<ul>
<li>none模式下，消息投递是不可靠的，可能丢失</li>
<li>auto模式类似事务机制，出现异常时返回nack，消息回滚到mq；没有异常，返回ack</li>
<li>manual：自己根据业务情况，判断什么时候该ack</li>
</ul>
<p>一般，我们都是使用默认的auto即可。</p>
<h4 id="演示none模式"><a href="#演示none模式" class="headerlink" title="演示none模式"></a>演示none模式</h4><p>修改consumer服务的application.yml文件，添加下面内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 关闭ack</span></span><br></pre></td></tr></table></figure>

<p>修改consumer服务中的方法，模拟一个消息处理异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者接收到simple.queue的消息：【&#123;&#125;】&quot;</span>, msg);</span><br><span class="line">    <span class="comment">// 模拟异常</span></span><br><span class="line">    System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;消息处理完成！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试可以发现，当消息处理抛异常时，消息依然被RabbitMQ删除了。</p>
<h4 id="演示auto模式"><a href="#演示auto模式" class="headerlink" title="演示auto模式"></a>演示auto模式</h4><p>再次把确认机制修改为auto:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动ack</span></span><br></pre></td></tr></table></figure>

<p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为unack（未确定状态）：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718171705383.png" alt="image-20210718171705383"></p>
<p>抛出异常后，因为Spring会自动返回nack，所以消息恢复至Ready状态，并且没有被RabbitMQ删除：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718171759179.png" alt="image-20210718171759179"></p>
<h3 id="消费失败重试机制"><a href="#消费失败重试机制" class="headerlink" title="消费失败重试机制"></a>消费失败重试机制</h3><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718172746378.png" alt="image-20210718172746378"></p>
<p>怎么办呢？</p>
<h4 id="本地重试"><a href="#本地重试" class="headerlink" title="本地重试"></a>本地重试</h4><p>我们可以利用Spring的retry机制，在消费者收到消息后，运行过程中消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p>
<p>修改consumer服务的application.yml文件，添加内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 初始的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>



<p>重启consumer服务，重复之前的测试。可以发现：</p>
<ul>
<li>在重试3次后，SpringAMQP会抛出异常AmqpRejectAndDontRequeueException，说明本地重试触发了</li>
<li>查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是ack，mq删除消息了</li>
</ul>
<p>结论：</p>
<ul>
<li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li>
<li>重试达到最大次数后，Spring会返回ack，消息会被丢弃</li>
</ul>
<h4 id="失败策略"><a href="#失败策略" class="headerlink" title="失败策略"></a>失败策略</h4><p>在之前的测试中，达到最大重试次数后，消息会被丢弃，这是由Spring内部机制决定的。</p>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecovery接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
<p>比较优雅的一种处理方案是RepublishMessageRecoverer，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p>
<p>1）在consumer服务中定义处理失败消息的交换机和队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）定义一个RepublishMessageRecoverer，关联队列和交换机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.mq.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.MessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者自动ACK的情况下，当消费者有异常，Spring会感知到RabbitListener中的异常，不会ACK并且会将消息requeue回原来的队列中。</span></span><br><span class="line"><span class="comment"> * 但是requeue回队列中就又会立刻被消费者收到并且异常，这样就会一直requeue，从而降低MQ的吞吐量。因此我们配置了Spring本地重试，</span></span><br><span class="line"><span class="comment"> * 这样本地重试一定次数（我们可以配置）后，SpringAMQP会抛出AmqpRejectAndDontRequeueException（说明本地重试触发了消息不会requeue了）</span></span><br><span class="line"><span class="comment"> * 并且SpringAMQP会返回ACK给RabbitMQ服务器将消息删除。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</span></span><br><span class="line"><span class="comment"> * 重试达到最大次数后，Spring会返回ack，相当于Spring默认本地重试一定次数后消息一定会被成功消费，消息会被丢弃</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个丢弃策略是默认的，但是这样就会造成消息丢失，并不好，因此我们需要有一个MessageRecovery接口来处理，这个接口包含3种实现：</span></span><br><span class="line"><span class="comment"> * RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</span></span><br><span class="line"><span class="comment"> * ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队</span></span><br><span class="line"><span class="comment"> * RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们选择RepublishMessageRecoverer，处理消息失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</span></span><br><span class="line"><span class="comment"> * 配置就是本类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当消费者出现异常了，异常消息的处理方案可以使用这种，也可以使用死信交换机那种。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/7/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepublishMessageRecovererConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 专门存放处理失败的消息的交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放异常消息的队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue()).to(errorMessageExchange()).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个RepublishMessageRecoverer，关联队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>如何确保RabbitMQ消息的可靠性？</p>
<ul>
<li>开启生产者确认机制，确保生产者的消息能到达队列</li>
<li>开启持久化功能，确保消息未消费前在队列中不会丢失</li>
<li>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</li>
<li>开启消费者失败重试机制，并设置MessageRecoverer，多次重试失败后将消息投递到异常交换机，交由人工处理</li>
</ul>
<h2 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h2><h3 id="初识死信交换机"><a href="#初识死信交换机" class="headerlink" title="初识死信交换机"></a>初识死信交换机</h3><h4 id="什么是死信交换机"><a href="#什么是死信交换机" class="headerlink" title="什么是死信交换机"></a>什么是死信交换机</h4><p>什么是死信？</p>
<p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p>
<ul>
<li>消息被消费者使用reject拒绝（丢弃）了或使用nack声明消费失败了，并且消息的requeue参数设置为false<ul>
<li>情况一：比如收到消息后消费者出现异常，本地重试相应次数后的默认策略（上面介绍过），消息reject情况。</li>
<li>情况二：比如设置了手动ACK机制。消费者端手动NACK了，并且requeue参数设置为了false。消息requeue&#x3D;false情况。</li>
</ul>
</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息满了，无法投递</li>
</ul>
<p>如果这个包含死信的队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>（Dead Letter Exchange，检查DLX）。</p>
<p>如图，一个消息被消费者拒绝了，变成了死信：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174328383.png" alt="image-20210718174328383"></p>
<p>因为simple.queue绑定了死信交换机 dl.direct，因此死信会投递给这个交换机：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174416160.png" alt="image-20210718174416160"></p>
<p>如果这个死信交换机也绑定了一个队列，则消息最终会进入这个存放死信的队列：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174506856.png" alt="image-20210718174506856"></p>
<p>另外，队列将死信投递给死信交换机时，必须知道两个信息：</p>
<ul>
<li>死信交换机名称</li>
<li>死信交换机与死信队列绑定的RoutingKey</li>
</ul>
<p>这样才能确保投递的消息能到达死信交换机，并且正确的路由到死信队列。</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210821073801398.png" alt="image-20210821073801398"></p>
<h4 id="利用死信交换机接收死信（拓展）"><a href="#利用死信交换机接收死信（拓展）" class="headerlink" title="利用死信交换机接收死信（拓展）"></a>利用死信交换机接收死信（拓展）</h4><p>在失败重试策略中，默认的RejectAndDontRequeueRecoverer会在本地重试次数耗尽后，发送reject给RabbitMQ，消息变成死信，被丢弃。</p>
<p>我们可以给simple.queue添加一个死信交换机，给死信交换机绑定一个队列。这样消息变成死信后也不会丢弃，而是最终投递到死信交换机，路由到与死信交换机绑定的队列。</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718174506856.png" alt="image-20210718174506856"></p>
<p>我们在consumer服务中，定义一组死信交换机、死信队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.mq.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CHAN 注：与图中不一致。图只是思路，这个类是我自己配置的。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/7/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 声明普通的queue队列，并且为其指定死信交换机：dl.direct</span></span><br><span class="line">    <span class="comment">// 这样这个普通的队列中如果有死信，那么死信就会进到这个死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;normal.queue&quot;</span>)<span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">                .deadLetterExchange(<span class="string">&quot;dl.direct&quot;</span>)<span class="comment">// 指定死信交换机</span></span><br><span class="line">                .deadLetterRoutingKey(<span class="string">&quot;dl&quot;</span>)<span class="comment">// 指定死信交换机和死信队列绑定的key</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明死信交换机 dl.direct</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;dl.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明存储死信的队列 dl.queue</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;dl.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将死信队列 与 死信交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">dlBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlQueue()).to(dlExchange()).with(<span class="string">&quot;dl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>什么样的消息会成为死信？</p>
<ul>
<li>消息被消费者reject或者返回nack</li>
<li>消息超时未消费</li>
<li>队列满了</li>
</ul>
<p>如何给队列指定死信交换机？</p>
<ul>
<li>给队列设置dead-letter-exchange属性，指定一个交换机</li>
<li>给队列设置dead-letter-routing-key属性，设置死信交换机与死信队列的RoutingKey</li>
</ul>
<p>死信交换机的使用场景是什么？</p>
<ul>
<li>如果队列绑定了死信交换机，死信会投递到死信交换机；</li>
<li>可以利用死信交换机收集所有消费者处理失败的消息（死信），交由人工处理，进一步提高消息队列的可靠性。</li>
</ul>
<h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p>一个队列中的消息如果超时未消费，则会变为死信，超时分为两种情况：</p>
<ul>
<li>消息所在的队列设置了超时时间</li>
<li>消息本身设置了超时时间</li>
</ul>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718182643311.png" alt="image-20210718182643311"></p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/2022-06-24_22-05.png" alt="2022-06-24_22-05.png"></p>
<h4 id="接收超时死信的死信交换机"><a href="#接收超时死信的死信交换机" class="headerlink" title="接收超时死信的死信交换机"></a>接收超时死信的死信交换机</h4><p>在consumer服务中，定义一个新的消费者，并且声明死信交换机、死信队列，这个消费者消费死信队列中的死信，也就是正常队列超时或者正常队列中的消息超时从而进到死信交换机（前提是这个正常队列创建时指定了死信交换机），进而进到死信队列中的消息，业务中可看做延迟消息。</p>
<p>注解方式声明死信交换机和死信队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;dl.ttl.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;dl.ttl.direct&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;dl.ttl&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDlQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 dl.ttl.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="声明一个队列，并且指定TTL"><a href="#声明一个队列，并且指定TTL" class="headerlink" title="声明一个队列，并且指定TTL"></a>声明一个队列，并且指定TTL</h4><p>要给队列设置超时时间，需要在声明队列时配置x-message-ttl属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;ttl.queue&quot;</span>) <span class="comment">// 指定普通队列名称，并持久化</span></span><br><span class="line">        .ttl(<span class="number">10000</span>) <span class="comment">// 设置队列的超时时间，10秒</span></span><br><span class="line">        .deadLetterExchange(<span class="string">&quot;dl.ttl.direct&quot;</span>) <span class="comment">// 指定死信交换机</span></span><br><span class="line">        .deadLetterRoutingKey(<span class="string">&quot;dl.ttl&quot;</span>)<span class="comment">// 指定死信交换机和死信队列绑定的key</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个队列设定了死信交换机为<code>dl.ttl.direct</code></p>
<p>声明交换机，将ttl.queue与交换机绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">ttlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;ttl.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">ttlBinding</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with(<span class="string">&quot;ttl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>或者使用@Bean的方式声明死信交换机和死信队列也可。</p>
<p>下面是使用@Bean的方式声明死信交换机和死信队列并且使用@Bean的方式创建可超时的普通队列的整体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chan.mq.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TTL延时消息也是基于死信交换机和死信队列实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/7/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TTLMessageWithDLConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个队列，并且指定TTL，这个队列设定了死信交换机为dl.ttl.direct</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;ttl.queue&quot;</span>)<span class="comment">// 指定普通队列名称，并持久化</span></span><br><span class="line">                .ttl(<span class="number">10000</span>)<span class="comment">// 设置队列的超时时间，10秒，普通队列超时，其中的消息就会变为死信进入死信交换机，我们只需要监听死信队列就可以实现延迟消息的效果</span></span><br><span class="line">                .deadLetterExchange(<span class="string">&quot;dl.ttl.direct&quot;</span>)<span class="comment">// 指定死信交换机</span></span><br><span class="line">                .deadLetterRoutingKey(<span class="string">&quot;dl.ttl&quot;</span>)<span class="comment">// 指定死信交换机和死信队列绑定的key</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明交换机，将ttl.queue与交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">ttlExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;ttl.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">ttlBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with(<span class="string">&quot;ttl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlTTLExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;dl.ttl.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlTTLQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;dl.ttl.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定死信队列到死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">dlTTLBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlTTLQueue()).to(dlTTLExchange()).with(<span class="string">&quot;dl.ttl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DlTtlQueueListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;dl.ttl.queue&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDlQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到 dl.ttl.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>发送消息，但是不要指定TTL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ttlqueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">testSendToTTLQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, ttl queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>, <span class="string">&quot;ttl&quot;</span>, message, correlationData);</span><br><span class="line">    <span class="comment">// 记录日志</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送消息的日志：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718191657478.png" alt="image-20210718191657478"></p>
<p>查看下接收消息的日志：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718191738706.png" alt="image-20210718191738706"></p>
<p>因为队列的TTL值是10000ms，也就是10秒。可以看到消息发送与接收之间的时差刚好是10秒。</p>
<h4 id="发送消息时，设定TTL"><a href="#发送消息时，设定TTL" class="headerlink" title="发送消息时，设定TTL"></a>发送消息时，设定TTL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 声明普通的queue队列，并且为其指定死信交换机：dl.direct</span></span><br><span class="line">    <span class="comment">// 这样这个普通的队列中如果有死信，那么死信就会进到这个死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;normal.queue&quot;</span>)<span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">                .deadLetterExchange(<span class="string">&quot;dl.direct&quot;</span>)<span class="comment">// 指定死信交换机</span></span><br><span class="line">                .deadLetterRoutingKey(<span class="string">&quot;dl&quot;</span>)<span class="comment">// 指定死信交换机和死信队列绑定的key</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明死信交换机 dl.direct</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">dlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;dl.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明存储死信的队列 dl.queue</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;dl.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将死信队列 与 死信交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">dlBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(dlQueue()).to(dlExchange()).with(<span class="string">&quot;dl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DlQueueListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;dl.queue&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDlQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到 dl.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在发送消息时，也可以指定TTL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于我们需要设置消息的TTL超时时间，因此需要使用MessageBuilder的方式发送消息。当使用MessageBuilder发送消息到MQ时，会有一个问题：</span></span><br><span class="line"><span class="comment"> * 就是当我们项目中同时配置了Jackson2JsonMessageConverter(将对象类型的消息序列化成JSON)，消息序列化时会出错导致异常。</span></span><br><span class="line"><span class="comment"> * 取消这个序列化配置，就不会出错了，但是取消序列化配置之后，发送对象类型的消息（比如消息体是一个Book类型）时又会报错。</span></span><br><span class="line"><span class="comment"> * 显示SimpleMessageConverter只能转换String、字节数组等基本类型，因此我们可以让这个对象实现Serializable；</span></span><br><span class="line"><span class="comment"> * 但是不配置JSON序列化，而使用Java的Serializable序列化的话，将对象消息发送到MQ服务器时可读性太差。</span></span><br><span class="line"><span class="comment"> * 因此，最好的方式是我们自己将对象序列化成JSON字符串之后，再将对象的JSON字符串发送到MQ，消费者收到JSON之后再将JSON序列化成对象包装类。</span></span><br><span class="line"><span class="comment"> * 简单来说就是如果我们想发送一个我们自己的对象类型到MQ，我们自己完成JSON序列化和反序列化，不用通过配置让MQ帮我们完成。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> R</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttlmsg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">testSendTTLMsgToQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">        .withBody(<span class="string">&quot;hello, ttl message&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        .setDeliveryMode(MessageDeliveryMode.PERSISTENT)</span><br><span class="line">        .setExpiration(<span class="string">&quot;5000&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;normal.queue&quot;</span>, message, correlationData);</span><br><span class="line">    log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：消息生产者发送的消息类型和消息消费者接收的消息类型要一致！</strong></p>
<p>这次，发送与接收的延迟只有5秒。说明当队列、消息都设置了TTL时，任意一个到期就会成为死信。</p>
<h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>消息超时的两种方式是？</p>
<ul>
<li>给队列设置ttl属性，进入队列后超过ttl时间的消息变为死信</li>
<li>给消息设置ttl属性，队列接收到消息超过ttl时间后变为死信</li>
</ul>
<p>如何实现发送一个消息20秒后消费者才收到消息？</p>
<ul>
<li>给消息的目标队列指定死信交换机</li>
<li>将消费者监听的队列绑定到死信交换机</li>
<li>发送消息时给消息设置超时时间为20秒</li>
</ul>
<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>利用TTL结合死信交换机，我们实现了消息发出后，消费者延迟收到消息的效果。这种消息模式就称为延迟队列（Delay Queue）模式。</p>
<p>延迟队列的使用场景包括：</p>
<ul>
<li>延迟发送短信</li>
<li>用户下单，如果用户在15 分钟内未支付，则自动取消</li>
<li>预约工作会议，20分钟后自动通知所有参会人员</li>
</ul>
<p>因为延迟队列的需求非常多，所以RabbitMQ的官方也推出了一个插件，原生支持延迟队列效果。</p>
<p>这个插件就是DelayExchange插件。参考RabbitMQ的插件列表页面：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718192529342.png" alt="image-20210718192529342"></p>
<p>使用方式可以参考官网地址：<a target="_blank" rel="noopener" href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq</a></p>
<h4 id="安装DelayExchange插件"><a href="#安装DelayExchange插件" class="headerlink" title="安装DelayExchange插件"></a>安装DelayExchange插件</h4><p><a target="_blank" rel="noopener" href="https://chanservy.vercel.app/posts/20220622/rabbitmq-install.html">https://chanservy.vercel.app/posts/20220622/rabbitmq-install.html</a></p>
<h4 id="DelayExchange原理"><a href="#DelayExchange原理" class="headerlink" title="DelayExchange原理"></a>DelayExchange原理</h4><p>DelayExchange需要将一个交换机声明为delayed类型。当我们发送消息到delayExchange时，流程如下：</p>
<ul>
<li>接收消息</li>
<li>判断消息是否具备x-delay属性</li>
<li>如果有x-delay属性，说明是延迟消息，持久化到硬盘，读取x-delay值，作为延迟时间</li>
<li>返回routing not found结果给消息发送者</li>
<li>x-delay时间到期后，重新投递消息到指定队列</li>
</ul>
<h4 id="使用DelayExchange"><a href="#使用DelayExchange" class="headerlink" title="使用DelayExchange"></a>使用DelayExchange</h4><p>插件的使用也非常简单：声明一个交换机，交换机的类型可以是任意类型，只需要设定delayed属性为true即可，然后声明队列与其绑定即可。</p>
<h5 id="1）声明DelayExchange交换机"><a href="#1）声明DelayExchange交换机" class="headerlink" title="1）声明DelayExchange交换机"></a>1）声明DelayExchange交换机</h5><p>基于注解方式（推荐）：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718193747649.png" alt="image-20210718193747649"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建并监听延迟队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 延时队列可以使用这种，也可以使用死信交换机那种。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/7/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayExchange</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者接收到了delay.queue的延迟消息:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也可以基于@Bean的方式：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718193831076.png" alt="image-20210718193831076"></p>
<h5 id="2）发送消息"><a href="#2）发送消息" class="headerlink" title="2）发送消息"></a>2）发送消息</h5><p>发送消息时，一定要携带x-delay属性，指定延迟的时间：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718193917009.png" alt="image-20210718193917009"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/delay&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">testDelayQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备消息</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setName(<span class="string">&quot;蛤蟆先生去看心理医生&quot;</span>);</span><br><span class="line">    book.setAuthor(<span class="string">&quot;罗伯特&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">bookJson</span> <span class="operator">=</span> JSONUtil.toJsonStr(book);</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">        .withBody(bookJson.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        .setDeliveryMode(MessageDeliveryMode.PERSISTENT)</span><br><span class="line">        .setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">5000</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 2.准备CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, correlationData);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p>延迟队列插件的使用步骤包括哪些？</p>
<ul>
<li>声明一个交换机，添加delayed属性为true</li>
<li>发送消息时，添加x-delay头，值为超时时间</li>
</ul>
<h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><h3 id="消息堆积问题"><a href="#消息堆积问题" class="headerlink" title="消息堆积问题"></a>消息堆积问题</h3><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题。</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718194040498.png" alt="image-20210718194040498"></p>
<p>解决消息堆积有两种思路：</p>
<ul>
<li>增加更多消费者，提高消费速度。也就是我们之前说的work queue模式</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<p>要提升队列容积，把消息保存在内存中显然是不行的。</p>
<h3 id="惰性队列-1"><a href="#惰性队列-1" class="headerlink" title="惰性队列"></a>惰性队列</h3><p>从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的概念，也就是惰性队列。惰性队列的特征如下：</p>
<ul>
<li>接收到消息后直接存入磁盘而非内存</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<h4 id="基于命令行设置lazy-queue"><a href="#基于命令行设置lazy-queue" class="headerlink" title="基于命令行设置lazy-queue"></a>基于命令行设置lazy-queue</h4><p>而要设置一个队列为惰性队列，只需要在声明队列时，指定x-queue-mode属性为lazy即可。可以通过命令行将一个运行中的队列修改为惰性队列：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy <span class="string">&quot;^lazy-queue$&quot;</span> <span class="string">&#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27;</span> --apply-to queues  </span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li>
<li><code>set_policy</code> ：添加一个策略</li>
<li><code>Lazy</code> ：策略名称，可以自定义</li>
<li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li>
<li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li>
<li><code>--apply-to queues  </code>：策略的作用对象，是所有的队列</li>
</ul>
<h4 id="基于-Bean声明lazy-queue"><a href="#基于-Bean声明lazy-queue" class="headerlink" title="基于@Bean声明lazy-queue"></a>基于@Bean声明lazy-queue</h4><p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718194522223.png" alt="image-20210718194522223"></p>
<h4 id="基于-RabbitListener声明LazyQueue"><a href="#基于-RabbitListener声明LazyQueue" class="headerlink" title="基于@RabbitListener声明LazyQueue"></a>基于@RabbitListener声明LazyQueue</h4><p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718194539054.png" alt="image-20210718194539054"></p>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>消息堆积问题的解决方案？</p>
<ul>
<li>队列上绑定多个消费者，提高消费速度</li>
<li>使用惰性队列，可以再mq中保存更多消息</li>
</ul>
<p>惰性队列的优点有哪些？</p>
<ul>
<li>基于磁盘存储，消息上限高</li>
<li>没有间歇性的page-out，性能比较稳定</li>
</ul>
<p>惰性队列的缺点有哪些？</p>
<ul>
<li>基于磁盘存储，消息时效性会降低</li>
<li>性能受限于磁盘的IO</li>
</ul>
<h2 id="MQ集群"><a href="#MQ集群" class="headerlink" title="MQ集群"></a>MQ集群</h2><h3 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h3><p>RabbitMQ的是基于Erlang语言编写，而Erlang又是一个面向并发的语言，天然支持集群模式。RabbitMQ的集群有两种模式：</p>
<p>•<strong>普通集群</strong>：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。</p>
<p>•<strong>镜像集群</strong>：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。</p>
<p>镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ的3.8版本以后，推出了新的功能：<strong>仲裁队列</strong>来代替镜像集群，底层采用Raft协议确保主从的数据一致性。</p>
<h3 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h3><h4 id="集群结构和特征"><a href="#集群结构和特征" class="headerlink" title="集群结构和特征"></a>集群结构和特征</h4><p>普通集群，或者叫标准集群（classic cluster），具备下列特征：</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<p>结构如图：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718220843323.png" alt="image-20210718220843323"></p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p><a target="_blank" rel="noopener" href="https://chanservy.vercel.app/posts/20220622/rabbitmq-install.html">https://chanservy.vercel.app/posts/20220622/rabbitmq-install.html</a></p>
<h3 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h3><h4 id="集群结构和特征-1"><a href="#集群结构和特征-1" class="headerlink" title="集群结构和特征"></a>集群结构和特征</h4><p>镜像集群：本质是主从模式，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li>
<li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<p>结构如图：</p>
<p><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/img/image-20210718221039542.png" alt="image-20210718221039542"></p>
<h4 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h4><p><a target="_blank" rel="noopener" href="https://chanservy.vercel.app/posts/20220622/rabbitmq-install.html">https://chanservy.vercel.app/posts/20220622/rabbitmq-install.html</a></p>
<h3 id="仲裁队列"><a href="#仲裁队列" class="headerlink" title="仲裁队列"></a>仲裁队列</h3><h4 id="集群特征"><a href="#集群特征" class="headerlink" title="集群特征"></a>集群特征</h4><p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于Raft协议，强一致</li>
</ul>
<h4 id="部署-2"><a href="#部署-2" class="headerlink" title="部署"></a>部署</h4><p><a target="_blank" rel="noopener" href="https://chanservy.vercel.app/posts/20220622/rabbitmq-install.html">https://chanservy.vercel.app/posts/20220622/rabbitmq-install.html</a></p>
<h4 id="Java代码创建仲裁队列"><a href="#Java代码创建仲裁队列" class="headerlink" title="Java代码创建仲裁队列"></a>Java代码创建仲裁队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .durable(<span class="string">&quot;quorum.queue&quot;</span>) <span class="comment">// 持久化</span></span><br><span class="line">        .quorum() <span class="comment">// 仲裁队列</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SpringAMQP连接MQ集群"><a href="#SpringAMQP连接MQ集群" class="headerlink" title="SpringAMQP连接MQ集群"></a>SpringAMQP连接MQ集群</h4><p>注意，这里用address来代替host、port方式</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8071,</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8072,</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8073</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>









</div><div class="article-licensing box"><div class="licensing-title"><p>RabbitMQ学习记录</p><p><a href="https://chanservy.github.io/posts/20220622/rabbitmq-study.html">https://chanservy.github.io/posts/20220622/rabbitmq-study.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>迩东陈</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-06-22</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-08-31</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> CC BY-NC-SA 4.0</a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/RabbitMQ/">RabbitMQ </a></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/20220622/rabbitmq-install.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">RabbitMQ部署指南</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/20220611/elasticsearch-install.html"><span class="level-item">Elasticsearch安装记录</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "f7IR3RHtvyy3zbMnkj08F4Uv-gzGzoHsz",
            appKey: "ztlhTLYlXtUClUWYAQBB5h1U",
            
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/head/head.jpg" alt="ChanServy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ChanServy</p><p class="is-size-6 is-block">1579700161@qq.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>LiaoNing, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives/"><div><p class="heading">文章</p><div><p class="title">16</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/categories/"><div><p class="heading">分类</p><div><p class="title">6</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/tags/"><div><p class="heading">标签</p><div><p class="title">10</p></div></div></a></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/erdochan" target="_blank" rel="noopener"><i class="fab fa-github"></i>  关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#RabbitMQ-基础篇"><span class="level-left"><span class="level-item">1</span><span class="level-item">RabbitMQ-基础篇</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#初识MQ"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">初识MQ</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#同步和异步通讯"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">同步和异步通讯</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#同步通讯"><span class="level-left"><span class="level-item">1.1.1.1</span><span class="level-item">同步通讯</span></span></a></li><li><a class="level is-mobile" href="#异步通讯"><span class="level-left"><span class="level-item">1.1.1.2</span><span class="level-item">异步通讯</span></span></a></li></ul></li><li><a class="level is-mobile" href="#技术对比"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">技术对比</span></span></a></li></ul></li><li><a class="level is-mobile" href="#快速入门"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">快速入门</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#安装RabbitMQ"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">安装RabbitMQ</span></span></a></li><li><a class="level is-mobile" href="#RabbitMQ消息模型"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">RabbitMQ消息模型</span></span></a></li><li><a class="level is-mobile" href="#Demo案例"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">Demo案例</span></span></a></li><li><a class="level is-mobile" href="#入门案例"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">入门案例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#publisher实现"><span class="level-left"><span class="level-item">1.2.4.1</span><span class="level-item">publisher实现</span></span></a></li><li><a class="level is-mobile" href="#consumer实现"><span class="level-left"><span class="level-item">1.2.4.2</span><span class="level-item">consumer实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">1.2.5</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#SpringAMQP"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">SpringAMQP</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Basic-Queue-简单队列模型"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">Basic Queue 简单队列模型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#消息发送"><span class="level-left"><span class="level-item">1.3.1.1</span><span class="level-item">消息发送</span></span></a></li><li><a class="level is-mobile" href="#消息接收"><span class="level-left"><span class="level-item">1.3.1.2</span><span class="level-item">消息接收</span></span></a></li><li><a class="level is-mobile" href="#测试"><span class="level-left"><span class="level-item">1.3.1.3</span><span class="level-item">测试</span></span></a></li></ul></li><li><a class="level is-mobile" href="#WorkQueue"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">WorkQueue</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#消息发送-1"><span class="level-left"><span class="level-item">1.3.2.1</span><span class="level-item">消息发送</span></span></a></li><li><a class="level is-mobile" href="#消息接收-1"><span class="level-left"><span class="level-item">1.3.2.2</span><span class="level-item">消息接收</span></span></a></li><li><a class="level is-mobile" href="#测试-1"><span class="level-left"><span class="level-item">1.3.2.3</span><span class="level-item">测试</span></span></a></li><li><a class="level is-mobile" href="#能者多劳"><span class="level-left"><span class="level-item">1.3.2.4</span><span class="level-item">能者多劳</span></span></a></li><li><a class="level is-mobile" href="#总结-1"><span class="level-left"><span class="level-item">1.3.2.5</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#发布-x2F-订阅"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">发布/订阅</span></span></a></li><li><a class="level is-mobile" href="#Fanout"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">Fanout</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#声明队列和交换机"><span class="level-left"><span class="level-item">1.3.4.1</span><span class="level-item">声明队列和交换机</span></span></a></li><li><a class="level is-mobile" href="#消息发送-2"><span class="level-left"><span class="level-item">1.3.4.2</span><span class="level-item">消息发送</span></span></a></li><li><a class="level is-mobile" href="#消息接收-2"><span class="level-left"><span class="level-item">1.3.4.3</span><span class="level-item">消息接收</span></span></a></li><li><a class="level is-mobile" href="#总结-2"><span class="level-left"><span class="level-item">1.3.4.4</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Direct"><span class="level-left"><span class="level-item">1.3.5</span><span class="level-item">Direct</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基于注解声明队列和交换机"><span class="level-left"><span class="level-item">1.3.5.1</span><span class="level-item">基于注解声明队列和交换机</span></span></a></li><li><a class="level is-mobile" href="#消息发送-3"><span class="level-left"><span class="level-item">1.3.5.2</span><span class="level-item">消息发送</span></span></a></li><li><a class="level is-mobile" href="#总结-3"><span class="level-left"><span class="level-item">1.3.5.3</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Topic"><span class="level-left"><span class="level-item">1.3.6</span><span class="level-item">Topic</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#说明"><span class="level-left"><span class="level-item">1.3.6.1</span><span class="level-item">说明</span></span></a></li><li><a class="level is-mobile" href="#消息发送-4"><span class="level-left"><span class="level-item">1.3.6.2</span><span class="level-item">消息发送</span></span></a></li><li><a class="level is-mobile" href="#消息接收-3"><span class="level-left"><span class="level-item">1.3.6.3</span><span class="level-item">消息接收</span></span></a></li><li><a class="level is-mobile" href="#总结-4"><span class="level-left"><span class="level-item">1.3.6.4</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#消息转换器"><span class="level-left"><span class="level-item">1.3.7</span><span class="level-item">消息转换器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#测试默认转换器"><span class="level-left"><span class="level-item">1.3.7.1</span><span class="level-item">测试默认转换器</span></span></a></li><li><a class="level is-mobile" href="#配置JSON转换器"><span class="level-left"><span class="level-item">1.3.7.2</span><span class="level-item">配置JSON转换器</span></span></a></li></ul></li></ul></li></ul></li><li><a class="level is-mobile" href="#服务异步通信-高级篇"><span class="level-left"><span class="level-item">2</span><span class="level-item">服务异步通信-高级篇</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#消息可靠性"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">消息可靠性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#生产者消息确认"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">生产者消息确认</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#修改配置"><span class="level-left"><span class="level-item">2.1.1.1</span><span class="level-item">修改配置</span></span></a></li><li><a class="level is-mobile" href="#定义Return回调"><span class="level-left"><span class="level-item">2.1.1.2</span><span class="level-item">定义Return回调</span></span></a></li><li><a class="level is-mobile" href="#定义ConfirmCallback"><span class="level-left"><span class="level-item">2.1.1.3</span><span class="level-item">定义ConfirmCallback</span></span></a></li></ul></li><li><a class="level is-mobile" href="#消息持久化"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">消息持久化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#交换机持久化"><span class="level-left"><span class="level-item">2.1.2.1</span><span class="level-item">交换机持久化</span></span></a></li><li><a class="level is-mobile" href="#队列持久化"><span class="level-left"><span class="level-item">2.1.2.2</span><span class="level-item">队列持久化</span></span></a></li><li><a class="level is-mobile" href="#消息持久化-1"><span class="level-left"><span class="level-item">2.1.2.3</span><span class="level-item">消息持久化</span></span></a></li></ul></li><li><a class="level is-mobile" href="#消费者消息确认"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">消费者消息确认</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#演示none模式"><span class="level-left"><span class="level-item">2.1.3.1</span><span class="level-item">演示none模式</span></span></a></li><li><a class="level is-mobile" href="#演示auto模式"><span class="level-left"><span class="level-item">2.1.3.2</span><span class="level-item">演示auto模式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#消费失败重试机制"><span class="level-left"><span class="level-item">2.1.4</span><span class="level-item">消费失败重试机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#本地重试"><span class="level-left"><span class="level-item">2.1.4.1</span><span class="level-item">本地重试</span></span></a></li><li><a class="level is-mobile" href="#失败策略"><span class="level-left"><span class="level-item">2.1.4.2</span><span class="level-item">失败策略</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结-5"><span class="level-left"><span class="level-item">2.1.5</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#死信交换机"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">死信交换机</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#初识死信交换机"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">初识死信交换机</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是死信交换机"><span class="level-left"><span class="level-item">2.2.1.1</span><span class="level-item">什么是死信交换机</span></span></a></li><li><a class="level is-mobile" href="#利用死信交换机接收死信（拓展）"><span class="level-left"><span class="level-item">2.2.1.2</span><span class="level-item">利用死信交换机接收死信（拓展）</span></span></a></li><li><a class="level is-mobile" href="#总结-6"><span class="level-left"><span class="level-item">2.2.1.3</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#TTL"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">TTL</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#接收超时死信的死信交换机"><span class="level-left"><span class="level-item">2.2.2.1</span><span class="level-item">接收超时死信的死信交换机</span></span></a></li><li><a class="level is-mobile" href="#声明一个队列，并且指定TTL"><span class="level-left"><span class="level-item">2.2.2.2</span><span class="level-item">声明一个队列，并且指定TTL</span></span></a></li><li><a class="level is-mobile" href="#发送消息时，设定TTL"><span class="level-left"><span class="level-item">2.2.2.3</span><span class="level-item">发送消息时，设定TTL</span></span></a></li><li><a class="level is-mobile" href="#总结-7"><span class="level-left"><span class="level-item">2.2.2.4</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#延迟队列"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">延迟队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#安装DelayExchange插件"><span class="level-left"><span class="level-item">2.2.3.1</span><span class="level-item">安装DelayExchange插件</span></span></a></li><li><a class="level is-mobile" href="#DelayExchange原理"><span class="level-left"><span class="level-item">2.2.3.2</span><span class="level-item">DelayExchange原理</span></span></a></li><li><a class="level is-mobile" href="#使用DelayExchange"><span class="level-left"><span class="level-item">2.2.3.3</span><span class="level-item">使用DelayExchange</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1）声明DelayExchange交换机"><span class="level-left"><span class="level-item">2.2.3.3.1</span><span class="level-item">1）声明DelayExchange交换机</span></span></a></li><li><a class="level is-mobile" href="#2）发送消息"><span class="level-left"><span class="level-item">2.2.3.3.2</span><span class="level-item">2）发送消息</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结-8"><span class="level-left"><span class="level-item">2.2.3.4</span><span class="level-item">总结</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#惰性队列"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">惰性队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#消息堆积问题"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">消息堆积问题</span></span></a></li><li><a class="level is-mobile" href="#惰性队列-1"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">惰性队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基于命令行设置lazy-queue"><span class="level-left"><span class="level-item">2.3.2.1</span><span class="level-item">基于命令行设置lazy-queue</span></span></a></li><li><a class="level is-mobile" href="#基于-Bean声明lazy-queue"><span class="level-left"><span class="level-item">2.3.2.2</span><span class="level-item">基于@Bean声明lazy-queue</span></span></a></li><li><a class="level is-mobile" href="#基于-RabbitListener声明LazyQueue"><span class="level-left"><span class="level-item">2.3.2.3</span><span class="level-item">基于@RabbitListener声明LazyQueue</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结-9"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MQ集群"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">MQ集群</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#集群分类"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">集群分类</span></span></a></li><li><a class="level is-mobile" href="#普通集群"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">普通集群</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#集群结构和特征"><span class="level-left"><span class="level-item">2.4.2.1</span><span class="level-item">集群结构和特征</span></span></a></li><li><a class="level is-mobile" href="#部署"><span class="level-left"><span class="level-item">2.4.2.2</span><span class="level-item">部署</span></span></a></li></ul></li><li><a class="level is-mobile" href="#镜像集群"><span class="level-left"><span class="level-item">2.4.3</span><span class="level-item">镜像集群</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#集群结构和特征-1"><span class="level-left"><span class="level-item">2.4.3.1</span><span class="level-item">集群结构和特征</span></span></a></li><li><a class="level is-mobile" href="#部署-1"><span class="level-left"><span class="level-item">2.4.3.2</span><span class="level-item">部署</span></span></a></li></ul></li><li><a class="level is-mobile" href="#仲裁队列"><span class="level-left"><span class="level-item">2.4.4</span><span class="level-item">仲裁队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#集群特征"><span class="level-left"><span class="level-item">2.4.4.1</span><span class="level-item">集群特征</span></span></a></li><li><a class="level is-mobile" href="#部署-2"><span class="level-left"><span class="level-item">2.4.4.2</span><span class="level-item">部署</span></span></a></li><li><a class="level is-mobile" href="#Java代码创建仲裁队列"><span class="level-left"><span class="level-item">2.4.4.3</span><span class="level-item">Java代码创建仲裁队列</span></span></a></li><li><a class="level is-mobile" href="#SpringAMQP连接MQ集群"><span class="level-left"><span class="level-item">2.4.4.4</span><span class="level-item">SpringAMQP连接MQ集群</span></span></a></li></ul></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/icarus-favicon.svg" alt="迩东陈" height="28"></a><p class="is-size-7"><span>&copy; 2022 迩东陈</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="ChanServy GitHub" href="https://github.com/ChanServy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>