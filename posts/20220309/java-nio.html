<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java NIO - 迩东陈</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="迩东陈"><meta name="msapplication-TileImage" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/head/star.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="迩东陈"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="笔记总结源自：Nyima boke。Java NIO 简介Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 IO与NIO的区别   IO NIO    面向流(Stream"><meta property="og:type" content="blog"><meta property="og:title" content="Java NIO"><meta property="og:url" content="https://chanservy.github.io/posts/20220309/java-nio.html"><meta property="og:site_name" content="迩东陈"><meta property="og:description" content="笔记总结源自：Nyima boke。Java NIO 简介Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 IO与NIO的区别   IO NIO    面向流(Stream"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109084453.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109085054.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109091555.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145709.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145753.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145822.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145852.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145905.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109151057.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109151520.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109153039.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109153439.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109154113.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109154803.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109211055.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109214801.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111082427.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111082547.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111083219.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111083230.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111090126.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112165417.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112163633.png"><meta property="og:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112164022.png"><meta property="article:published_time" content="2022-03-09T14:08:12.000Z"><meta property="article:modified_time" content="2022-08-31T08:06:20.587Z"><meta property="article:author" content="迩东陈"><meta property="article:tag" content="NIO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109084453.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://chanservy.github.io/posts/20220309/java-nio.html"},"headline":"Java NIO","image":["https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109084453.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109085054.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109091555.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145709.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145753.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145822.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145852.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145905.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109151057.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109151520.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109153039.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109153439.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109154113.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109154803.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109211055.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109214801.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111082427.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111082547.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111083219.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111083230.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111090126.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112165417.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112163633.png","https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112164022.png"],"datePublished":"2022-03-09T14:08:12.000Z","dateModified":"2022-08-31T08:06:20.587Z","author":{"@type":"Person","name":"迩东陈"},"publisher":{"@type":"Organization","name":"迩东陈","logo":{"@type":"ImageObject","url":"https://chanservy.github.io/img/icarus-favicon.svg"}},"description":"笔记总结源自：Nyima boke。Java NIO 简介Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 IO与NIO的区别   IO NIO    面向流(Stream"}</script><link rel="canonical" href="https://chanservy.github.io/posts/20220309/java-nio.html"><link rel="icon" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/head/star.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/icarus-favicon.svg" alt="迩东陈" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives/">Archives</a><a class="navbar-item" href="/categories/">Categories</a><a class="navbar-item" href="/tags/">Tags</a><a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="ChanServy GitHub" href="https://github.com/ChanServy"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Java NIO</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2022-03-09T14:08:12.000Z" title="2022-03-09T14:08:12.000Z">2022-03-09</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2022-08-31T08:06:20.587Z" title="2022-08-31T08:06:20.587Z">2022-08-31</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/NIO/">NIO</a></span><span class="level-item"><i class="far fa-clock"></i> 35 分钟读完 (大约5278个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>笔记总结源自：Nyima boke。<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2020/11/30/Java%20NIO/">Java NIO</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，<strong>可以替代标准的Java IO API</strong>。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持<strong>面向缓冲区的、基于通道的IO操作</strong>。NIO将以更加高效的方式进行文件的读写操作。</p>
<h2 id="IO与NIO的区别"><a href="#IO与NIO的区别" class="headerlink" title="IO与NIO的区别"></a>IO与NIO的区别</h2><table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流(Stream Oriented)</td>
<td>面向缓冲区(Buffer Oriented)</td>
</tr>
<tr>
<td>阻塞IO(Blocking IO)</td>
<td>非阻塞IO(NonBlocking IO)</td>
</tr>
<tr>
<td>无</td>
<td>选择器(Selectors)</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="面向流和缓冲区"><a href="#面向流和缓冲区" class="headerlink" title="面向流和缓冲区"></a>面向流和缓冲区</h3><p><strong>IO</strong></p>
<p>传统IO在传输数据时，根据输入输出的不同需要分别建立不同的链接，而且传输的数据是以流的形式在链接上进行传输的。</p>
<p>就像自来水要通过水管将自来水厂和家连接起来一样。</p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109084453.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109084453.png" alt="img"></a></p>
<p><strong>NIO</strong></p>
<p>NIO在传输数据时，会在输入输出端之间建立<strong>通道</strong>，然后将数据放入到<strong>缓冲区</strong>中。缓冲区通过通道来传输数据。</p>
<p>这里通道就像是铁路，能够连通两个地点。缓冲区就像是火车，能够真正地进行数据的传输。</p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109085054.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109085054.png" alt="img"></a></p>
<h2 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h2><p>Java NIO系统的核心在于：<code>通道(Channel)和缓冲区(Buffer)</code>。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p>
<p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong>。</p>
<h2 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h2><h3 id="缓冲区类型"><a href="#缓冲区类型" class="headerlink" title="缓冲区类型"></a>缓冲区类型</h3><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(<strong>boolean 除外</strong>) ，有以下Buffer 常用子类：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p><strong>各种类型的缓冲区中，都有一个对应类型的数组</strong>，如：</p>
<p>ByteBuffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">byte</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br></pre></td></tr></table></figure>

<p>IntBuffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br></pre></td></tr></table></figure>

<p><strong>他们的继承关系如下</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109091555.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109091555.png" alt="img"></a></p>
<h3 id="获取缓冲区"><a href="#获取缓冲区" class="headerlink" title="获取缓冲区"></a>获取缓冲区</h3><p>通过<strong>allocate方法</strong>可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个容量大小为1024字节的字节缓冲区</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><p>缓冲区的父类Buffer中有几个核心属性，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> capacity;</span><br></pre></td></tr></table></figure>

<ul>
<li>capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改。</li>
<li>limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong>。</li>
<li>position：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong>。</li>
<li>mark：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li>
</ul>
<p>以上四个属性必须满足以下要求：</p>
<p><strong>mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></p>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul>
<li>put()方法可以将一个数据放入到缓冲区中。</li>
<li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity &#x3D; limit ，为缓冲区容量的值。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145709.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145709.png" alt="img"></a></p>
<h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul>
<li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 &#x2F; 读-&gt;写。</li>
<li>进行该操作后<ul>
<li>如果是写模式-&gt;读模式，position &#x3D; 0 ， limit 指向最后一个元素的下一个位置，capacity不变。</li>
<li>如果是读-&gt;写，则恢复为put()方法中的值。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145753.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145753.png" alt="img"></a></p>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul>
<li>get()方法会读取缓冲区中的一个值。</li>
<li>进行该操作后，position会+1，如果超过了limit则会抛出异常。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145822.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145822.png" alt="img"></a></p>
<h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul>
<li>该方法<strong>只能在读模式下使用</strong>。</li>
<li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145852.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145852.png" alt="img"></a></p>
<h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h4><ul>
<li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position &#x3D; 0, capacity &#x3D; limit。</li>
<li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145905.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109145905.png" alt="img"></a></p>
<h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul>
<li>mark()方法会将postion的值保存到mark属性中。</li>
<li>reset()方法会将position的值改为mark中保存的值。</li>
</ul>
<h4 id="使用展示"><a href="#使用展示" class="headerlink" title="使用展示"></a>使用展示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;放入前参数&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;position &quot;</span> + byteBuffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;limit &quot;</span> + byteBuffer.limit());</span><br><span class="line">        System.out.println(<span class="string">&quot;capacity &quot;</span> + byteBuffer.capacity());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------put()------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;放入3个数据&quot;</span>);</span><br><span class="line">        <span class="type">byte</span> <span class="variable">bt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        byteBuffer.put(bt);</span><br><span class="line">        byteBuffer.put(bt);</span><br><span class="line">        byteBuffer.put(bt);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;放入后参数&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;position &quot;</span> + byteBuffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;limit &quot;</span> + byteBuffer.limit());</span><br><span class="line">        System.out.println(<span class="string">&quot;capacity &quot;</span> + byteBuffer.capacity());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------flip()-get()------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;读取一个数据&quot;</span>);</span><br><span class="line">        <span class="comment">// 切换模式</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        byteBuffer.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;读取后参数&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;position &quot;</span> + byteBuffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;limit &quot;</span> + byteBuffer.limit());</span><br><span class="line">        System.out.println(<span class="string">&quot;capacity &quot;</span> + byteBuffer.capacity());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------rewind()------&quot;</span>);</span><br><span class="line">        byteBuffer.rewind();</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后参数&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;position &quot;</span> + byteBuffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;limit &quot;</span> + byteBuffer.limit());</span><br><span class="line">        System.out.println(<span class="string">&quot;capacity &quot;</span> + byteBuffer.capacity());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------clear()------&quot;</span>);</span><br><span class="line">        <span class="comment">// 清空缓冲区，这里只是恢复了各个属性的值，但是缓冲区里的数据依然存在</span></span><br><span class="line">        <span class="comment">// 但是下次写入的时候会覆盖缓冲区中之前的数据</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空后参数&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;position &quot;</span> + byteBuffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;limit &quot;</span> + byteBuffer.limit());</span><br><span class="line">        System.out.println(<span class="string">&quot;capacity &quot;</span> + byteBuffer.capacity());</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空后获得数据&quot;</span>);</span><br><span class="line">        System.out.println(byteBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">放入前参数</span><br><span class="line">position 0</span><br><span class="line">limit 1024</span><br><span class="line">capacity 1024</span><br><span class="line"></span><br><span class="line">------put()------</span><br><span class="line">放入3个数据</span><br><span class="line">放入后参数</span><br><span class="line">position 3</span><br><span class="line">limit 1024</span><br><span class="line">capacity 1024</span><br><span class="line"></span><br><span class="line">------flip()-get()------</span><br><span class="line">读取一个数据</span><br><span class="line">读取后参数</span><br><span class="line">position 1</span><br><span class="line">limit 3</span><br><span class="line">capacity 1024</span><br><span class="line"></span><br><span class="line">------rewind()------</span><br><span class="line">恢复后参数</span><br><span class="line">position 0</span><br><span class="line">limit 3</span><br><span class="line">capacity 1024</span><br><span class="line"></span><br><span class="line">------clear()------</span><br><span class="line">清空后参数</span><br><span class="line">position 0</span><br><span class="line">limit 1024</span><br><span class="line">capacity 1024</span><br><span class="line"></span><br><span class="line">清空后获得数据</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="非直接缓冲区和直接缓冲区"><a href="#非直接缓冲区和直接缓冲区" class="headerlink" title="非直接缓冲区和直接缓冲区"></a>非直接缓冲区和直接缓冲区</h3><h4 id="非直接缓冲区"><a href="#非直接缓冲区" class="headerlink" title="非直接缓冲区"></a>非直接缓冲区</h4><p>通过<strong>allocate()<strong>方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM</strong>堆内存</strong>之中的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆内存中开辟空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapByteBuffer</span>(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line">HeapByteBuffer(<span class="type">int</span> cap, <span class="type">int</span> lim) &#123;        <span class="comment">// package-private</span></span><br><span class="line">    <span class="comment">// new byte[cap] 创建数组，在堆内存中开辟空间</span></span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="title class_">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = new byte[cap];</span></span><br><span class="line"><span class="comment">    offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109151057.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109151057.png" alt="img"></a></p>
<p>通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。<strong>都需要经过JVM和操作系统</strong>，数据在两个地址空间中传输时，会<strong>copy</strong>一份保存在对方的空间中。所以费直接缓冲区的读取效率较低。</p>
<h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p><strong>只有ByteBuffer可以获得直接缓冲区</strong>，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在<strong>物理内存</strong>之中的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 申请物理内存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109151520.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109151520.png" alt="img"></a></p>
<p>直接缓冲区通过在操作系统和JVM之间创建<strong>物理内存映射文件</strong>加快缓冲区数据读&#x2F;写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中。</p>
<h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Channel由java.nio.channels 包定义的。Channel 表示<strong>IO 源与目标打开的连接</strong>。Channel 类似于传统的“流”。只不过<strong>Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互。</strong></p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>应用程序进行读写操作调用函数时，<strong>底层调用的操作系统提供给用户的读写API</strong>，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，<strong>所有读写请求的指令都有CPU去执行</strong>，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低。</p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109153039.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109153039.png" alt="img"></a></p>
<p>后来，<strong>DMA</strong>(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，<strong>DMA会向CPU请求，让DMA去处理这些IO操作</strong>，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。<strong>当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109153439.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109153439.png" alt="img"></a></p>
<p>于是便有了<strong>Channel(通道)<strong>，Channel相当于一个</strong>专门用于IO操作的独立处理器</strong>，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求。</p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109154113.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109154113.png" alt="img"></a></p>
<h3 id="Java-Channel"><a href="#Java-Channel" class="headerlink" title="Java Channel"></a>Java Channel</h3><h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109154803.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109154803.png" alt="img"></a></p>
<ul>
<li>本地文件IO<ul>
<li>FileChannel</li>
</ul>
</li>
<li>网络IO<ul>
<li>SocketChanel、ServerSocketChannel：用于TCP传输</li>
<li>DatagramChannel：用于UDP传输</li>
</ul>
</li>
</ul>
<h4 id="获得通道的方法"><a href="#获得通道的方法" class="headerlink" title="获得通道的方法"></a>获得通道的方法</h4><p>获取通道的一种方式是对支持通道的<strong>对象调用getChannel() 方法</strong>。支持通道的类如下：</p>
<ul>
<li>FileInputStream</li>
<li>FileOutputStream</li>
<li>RandomAccessFile</li>
<li>DatagramSocket</li>
<li>Socket</li>
<li>ServerSocket</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 本地通道</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel1</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel2</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 网络通道</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel3</span> <span class="operator">=</span> socket.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">channel4</span> <span class="operator">=</span> serverSocket.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">channel5</span> <span class="operator">=</span> datagramSocket.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后要关闭通道</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也可以通过通道的静态方法open()来获取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">open</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">open1</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getChannel-非直接缓冲区"><a href="#getChannel-非直接缓冲区" class="headerlink" title="getChannel()+非直接缓冲区"></a>getChannel()+非直接缓冲区</h4><ul>
<li>getChannel()获得通道</li>
<li>allocate()获得<strong>非直接缓冲区</strong></li>
</ul>
<p>通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 获得通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用 try-catch-finally 保证关闭</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;</span>);</span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得通道</span></span><br><span class="line">            inChannel = is.getChannel();</span><br><span class="line">            outChannel = os.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得缓冲区，用于在通道中传输数据</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环将字节数据放入到buffer中，然后写入磁盘中</span></span><br><span class="line">            <span class="keyword">while</span> (inChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 切换模式</span></span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                outChannel.write(byteBuffer);</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>图片读取后，被写入到了指定位置</strong><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109211055.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109211055.png" alt="img"></a></p>
<h4 id="open-直接缓冲区"><a href="#open-直接缓冲区" class="headerlink" title="open()+直接缓冲区"></a>open()+直接缓冲区</h4><ul>
<li>通过open获得通道</li>
<li>通过FileChannel.map()获取直接缓冲区</li>
</ul>
<p>使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 通过open()方法来获得通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// outChannel需要为 READ WRITE CREATE模式</span></span><br><span class="line">        <span class="comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span></span><br><span class="line">        <span class="comment">// CREATE是因为要创建新的文件</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\3.jpg&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得直接缓冲区</span></span><br><span class="line">        <span class="type">MappedByteBuffer</span> <span class="variable">inMapBuf</span> <span class="operator">=</span> inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">        <span class="type">MappedByteBuffer</span> <span class="variable">outMapBuf</span> <span class="operator">=</span> outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[inMapBuf.limit()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输</span></span><br><span class="line">        inMapBuf.get(bytes);</span><br><span class="line">        outMapBuf.put(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭缓冲区，这里没有用try-catch-finally</span></span><br><span class="line">        inChannel.close();</span><br><span class="line">        outChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果，图片被创建</strong><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109214801.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201109214801.png" alt="img"></a></p>
<h4 id="通道间直接传输"><a href="#通道间直接传输" class="headerlink" title="通道间直接传输"></a>通道间直接传输</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">channelToChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 通过open()方法来获得通道</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.mp4&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// outChannel需要为 READ WRITE CREATE模式</span></span><br><span class="line">    <span class="comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span></span><br><span class="line">    <span class="comment">// CREATE是因为要创建新的文件</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\4.mp4&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通道间直接传输</span></span><br><span class="line">    inChannel.transferTo(<span class="number">0</span>, inChannel.size(), outChannel);</span><br><span class="line">    <span class="comment">// 对应的还有transferFrom</span></span><br><span class="line">    <span class="comment">// outChannel.transferFrom(inChannel, 0, inChannel.size());</span></span><br><span class="line"></span><br><span class="line">    inChannel.close();</span><br><span class="line">    outChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接缓冲区VS非直接缓冲区"><a href="#直接缓冲区VS非直接缓冲区" class="headerlink" title="直接缓冲区VS非直接缓冲区"></a>直接缓冲区VS非直接缓冲区</h4><p><strong>效率</strong></p>
<p>读取一个MP4文件，通过二者花费时间的多少来判定执行的速度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getChannel() + 非直接缓冲区耗时</span></span><br><span class="line"><span class="number">708</span></span><br><span class="line"><span class="comment">// open() + 直接缓冲区耗时</span></span><br><span class="line"><span class="number">115</span></span><br><span class="line"><span class="comment">// channel transferTo channel耗时</span></span><br><span class="line"><span class="number">47</span></span><br></pre></td></tr></table></figure>

<p><strong>内存占用</strong></p>
<p>直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得计算机运行速度变慢</p>
<h3 id="分散和聚集"><a href="#分散和聚集" class="headerlink" title="分散和聚集"></a>分散和聚集</h3><h4 id="分散读取"><a href="#分散读取" class="headerlink" title="分散读取"></a>分散读取</h4><p>分散读取（Scattering Reads）是指<strong>从Channel 中读取的数据“分散”到多个Buffer 中</strong></p>
<p><strong>注意</strong>：按照缓冲区的<strong>顺序</strong>，从Channel 中读取的数据依次将 Buffer 填满</p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111082427.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111082427.png" alt="img"></a></p>
<h4 id="聚集写入"><a href="#聚集写入" class="headerlink" title="聚集写入"></a>聚集写入</h4><p>聚集写入（Gathering Writes）是指将<strong>多个Buffer 中的数据“聚集”到Channel</strong></p>
<p>按照缓冲区的<strong>顺序</strong>，写入position 和limit 之间的数据到Channel</p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111082547.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111082547.png" alt="img"></a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> is.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> os.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得多个缓冲区，并且放入到缓冲区数组中</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        ByteBuffer[] byteBuffers = &#123;byteBuffer1, byteBuffer2&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分散读取</span></span><br><span class="line">        inChannel.read(byteBuffers);</span><br><span class="line"></span><br><span class="line">        byteBuffer1.flip();</span><br><span class="line">        byteBuffer2.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 聚集写入</span></span><br><span class="line">        outChannel.write(byteBuffers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111083219.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111083219.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111083230.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111083230.png" alt="img"></a></p>
<h2 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>双11买的快递到了，快递小哥给你打电话说马上到小区门口，麻烦在门口等一下，方便签收快递</p>
<ul>
<li>若为<strong>阻塞式</strong>的，你到了小区门口以后，快递小哥还没到的期间，你什么事儿也做不了</li>
<li>若为<strong>非阻塞式</strong>的，快递小哥将快递放到门卫处，门卫给你发消息说快递到了，麻烦去取一下。当快递还没到的时候你可以做你自己的事儿</li>
</ul>
<h4 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h4><p>传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，<strong>该线程被阻塞</strong>，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p>
<p>因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以<strong>服务器端必须为每个客户端都提供一个独立的线程进行处理</strong>，当服务器端需要处理大量客户端时，<strong>性能急剧下降</strong></p>
<p>也就是说，服务器在等待IO准备就绪的期间，<strong>线程处于阻塞状态</strong>，若为单线程，等待期间CPU未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待IO准备就绪时，CPU可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。</p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111090126.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201111090126.png" alt="img"></a></p>
<h4 id="非阻塞式网络通信-1"><a href="#非阻塞式网络通信-1" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h4><p>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，<strong>若没有数据可用时，该线程可以进行其他任务</strong>。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以<strong>单独的线程可以管理多个输入和输出通道</strong></p>
<p>因此，NIO 可以让服务器端<strong>使用一个或有限几个线程来同时处理连接到服务器端的所有客户端</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112165417.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112165417.png" alt="img"></a></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="阻塞式网络通信演示"><a href="#阻塞式网络通信演示" class="headerlink" title="阻塞式网络通信演示"></a>阻塞式网络通信演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建客户端通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">2022</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取信息</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\nio\\day3\\1.jpg&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        <span class="keyword">while</span> (fileChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fileChannel.close();</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建服务端通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\nio\\day3\\2.jpg&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定链接</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">2022</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取客户端的通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socketChannel.close();</span><br><span class="line">        fileChannel.close();</span><br><span class="line">        serverSocketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非阻塞式网络通信演示"><a href="#非阻塞式网络通信演示" class="headerlink" title="非阻塞式网络通信演示"></a>非阻塞式网络通信演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoNIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">2020</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            byteBuffer.put(str.getBytes());</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">2020</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将通道注册到选择器中，设定为接收操作</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 轮训接受</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="comment">// 获得事件的key</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 从选择器中获取通道</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> byteBuffer.limit();</span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(), <span class="number">0</span>, len));</span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h5><p>选择器（Selector）是<strong>SelectableChannle</strong> 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。<strong>Selector 是非阻塞IO 的核心</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112163633.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112163633.png" alt="img"></a></p>
<p><strong>选择器的创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个选择器</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>

<p><strong>绑定选择器</strong></p>
<p>通过调用通道的register方法可以绑定选择器，register方法有两个参数</p>
<ul>
<li><p>Selector：即绑定哪个选择器</p>
</li>
<li><p>ops：监听事件类型。ops有4个值可以选择，为<strong>SelectionKey</strong>的静态属性</p>
<p><a target="_blank" rel="noopener" href="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112164022.png"><img src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/CDN2/nio/20201112164022.png" alt="img"></a></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让选择器监听一种状态</span></span><br><span class="line">myChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="comment">// 让选择器监听多种状态</span></span><br><span class="line">myChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p><strong>SelectionKey</strong></p>
<p><strong>表示SelectableChannel 和Selector 之间的注册关系</strong>。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java NIO</p><p><a href="https://chanservy.github.io/posts/20220309/java-nio.html">https://chanservy.github.io/posts/20220309/java-nio.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>迩东陈</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-03-09</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-08-31</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> CC BY-NC-SA 4.0</a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/NIO/">NIO </a></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/20220315/netty-nio.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Netty学习之NIO基础</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/20211225/jvm.html"><span class="level-item">JVM 学习笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "f7IR3RHtvyy3zbMnkj08F4Uv-gzGzoHsz",
            appKey: "ztlhTLYlXtUClUWYAQBB5h1U",
            
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://blog-images-erdochan.oss-cn-beijing.aliyuncs.com/head/head.jpg" alt="ChanServy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ChanServy</p><p class="is-size-6 is-block">1579700161@qq.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>LiaoNing, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives/"><div><p class="heading">文章</p><div><p class="title">16</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/categories/"><div><p class="heading">分类</p><div><p class="title">6</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/tags/"><div><p class="heading">标签</p><div><p class="title">10</p></div></div></a></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/erdochan" target="_blank" rel="noopener"><i class="fab fa-github"></i>  关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#简介"><span class="level-left"><span class="level-item">1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#IO与NIO的区别"><span class="level-left"><span class="level-item">2</span><span class="level-item">IO与NIO的区别</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#面向流和缓冲区"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">面向流和缓冲区</span></span></a></li></ul></li><li><a class="level is-mobile" href="#通道与缓冲区"><span class="level-left"><span class="level-item">3</span><span class="level-item">通道与缓冲区</span></span></a></li><li><a class="level is-mobile" href="#缓冲区-Buffer"><span class="level-left"><span class="level-item">4</span><span class="level-item">缓冲区(Buffer)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#缓冲区类型"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">缓冲区类型</span></span></a></li><li><a class="level is-mobile" href="#获取缓冲区"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">获取缓冲区</span></span></a></li><li><a class="level is-mobile" href="#核心属性"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">核心属性</span></span></a></li><li><a class="level is-mobile" href="#核心方法"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">核心方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#put-方法"><span class="level-left"><span class="level-item">4.4.1</span><span class="level-item">put()方法</span></span></a></li><li><a class="level is-mobile" href="#flip-方法"><span class="level-left"><span class="level-item">4.4.2</span><span class="level-item">flip()方法</span></span></a></li><li><a class="level is-mobile" href="#get-方法"><span class="level-left"><span class="level-item">4.4.3</span><span class="level-item">get()方法</span></span></a></li><li><a class="level is-mobile" href="#rewind-方法"><span class="level-left"><span class="level-item">4.4.4</span><span class="level-item">rewind()方法</span></span></a></li><li><a class="level is-mobile" href="#clean-方法"><span class="level-left"><span class="level-item">4.4.5</span><span class="level-item">clean()方法</span></span></a></li><li><a class="level is-mobile" href="#mark-和reset-方法"><span class="level-left"><span class="level-item">4.4.6</span><span class="level-item">mark()和reset()方法</span></span></a></li><li><a class="level is-mobile" href="#使用展示"><span class="level-left"><span class="level-item">4.4.7</span><span class="level-item">使用展示</span></span></a></li></ul></li><li><a class="level is-mobile" href="#非直接缓冲区和直接缓冲区"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">非直接缓冲区和直接缓冲区</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#非直接缓冲区"><span class="level-left"><span class="level-item">4.5.1</span><span class="level-item">非直接缓冲区</span></span></a></li><li><a class="level is-mobile" href="#直接缓冲区"><span class="level-left"><span class="level-item">4.5.2</span><span class="level-item">直接缓冲区</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#通道-Channel"><span class="level-left"><span class="level-item">5</span><span class="level-item">通道(Channel)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-1"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#图解"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">图解</span></span></a></li><li><a class="level is-mobile" href="#Java-Channel"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">Java Channel</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#常用实现类"><span class="level-left"><span class="level-item">5.3.1</span><span class="level-item">常用实现类</span></span></a></li><li><a class="level is-mobile" href="#获得通道的方法"><span class="level-left"><span class="level-item">5.3.2</span><span class="level-item">获得通道的方法</span></span></a></li><li><a class="level is-mobile" href="#getChannel-非直接缓冲区"><span class="level-left"><span class="level-item">5.3.3</span><span class="level-item">getChannel()+非直接缓冲区</span></span></a></li><li><a class="level is-mobile" href="#open-直接缓冲区"><span class="level-left"><span class="level-item">5.3.4</span><span class="level-item">open()+直接缓冲区</span></span></a></li><li><a class="level is-mobile" href="#通道间直接传输"><span class="level-left"><span class="level-item">5.3.5</span><span class="level-item">通道间直接传输</span></span></a></li><li><a class="level is-mobile" href="#直接缓冲区VS非直接缓冲区"><span class="level-left"><span class="level-item">5.3.6</span><span class="level-item">直接缓冲区VS非直接缓冲区</span></span></a></li></ul></li><li><a class="level is-mobile" href="#分散和聚集"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">分散和聚集</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#分散读取"><span class="level-left"><span class="level-item">5.4.1</span><span class="level-item">分散读取</span></span></a></li><li><a class="level is-mobile" href="#聚集写入"><span class="level-left"><span class="level-item">5.4.2</span><span class="level-item">聚集写入</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#非阻塞式网络通信"><span class="level-left"><span class="level-item">6</span><span class="level-item">非阻塞式网络通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#概念"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">概念</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#举例"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">举例</span></span></a></li><li><a class="level is-mobile" href="#阻塞式网络通信"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">阻塞式网络通信</span></span></a></li><li><a class="level is-mobile" href="#非阻塞式网络通信-1"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">非阻塞式网络通信</span></span></a></li></ul></li><li><a class="level is-mobile" href="#使用"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">使用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#阻塞式网络通信演示"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">阻塞式网络通信演示</span></span></a></li><li><a class="level is-mobile" href="#非阻塞式网络通信演示"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">非阻塞式网络通信演示</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#选择器"><span class="level-left"><span class="level-item">6.2.2.1</span><span class="level-item">选择器</span></span></a></li></ul></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/icarus-favicon.svg" alt="迩东陈" height="28"></a><p class="is-size-7"><span>&copy; 2022 迩东陈</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="ChanServy GitHub" href="https://github.com/ChanServy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>